function love.conf(t)
  t.window = t.window or t.screen

  t.version = "0.10.2"                -- The LÃ–VE version this game was made for (string)
  t.window.title = "Brick Machine"        -- The window title (string)
  t.title = t.window.title        -- The window title (string)
  t.window.fullscreen = false        -- Enable fullscreen (boolean)
  --  t.window.fullscreentype = "normal" -- Standard fullscreen or desktop fullscreen mode (string)

  t.window.width = 506-- t.screen.width in 0.8.0 and earlier
  t.window.height = 506 -- t.screen.height in 0.8.0 and earlier
  t.screen = t.screen or t.window

end
local lg = love.graphics
local res = require 'resources'
local pixS = 8

local display = function(display, offX, offY, args)
    if args and args.border then
      lg.setColor(res.palette.on)
      lg.rectangle('line', offX-1.5, offY-1.5, pixS*display.w+2, pixS*display.h+2)
    end

    for x=0, display.w-1 do
      for y=0,display.h-1 do
        lg.setColor(display.isOn(x,y) and res.palette.on or res.palette.off)
        lg.rectangle('fill', 2+pixS*x+offX, 2+y*pixS+offY, pixS-5, pixS-5)
        lg.rectangle('line', .5+pixS*x+offX, .5+y*pixS+offY, pixS-2, pixS-2)
      end
    end
end

local lcd = function (val, x, y, len)
    lg.setFont(res.font.lcd)
    lg.setColor(res.palette.off)
    lg.print(string.rep("8", len), x, y)
    lg.setColor(res.palette.on)
    lg.print(string.rep(" ", len-tostring(val):len())..val, x, y)
end


return function(machine)
  lg.setColor(res.palette.bg)
  lg.rectangle('fill', 0, 0, lg:getWidth(), lg:getHeight())

  lg.setFont(res.font.sans)

  lg.setColor(machine.gameover and res.palette.on or res.palette.off)
  lg.print('GAME\nOVER', 350,100)

  lg.setColor(res.palette.on)

  lg.print('SCORE', 220,60) -- TODO 'HI-'
  lg.print('NEXT', 300,115)
  lg.print('SPEED', 300,230)
  lg.print('LEVEL', 300,280)
  lg.print('ROTATE', 300, 350)
  lg.print('<', 330,370)
  -- TODO fruits on the right side, note symbol, LINES instead of score

  lcd(machine.score, 300,55, 6)
  lcd(machine.speed, 370,230, 2)
  lcd(machine.level, 370,280, 2)

  lg.scale(2)
  display(machine.display.main, 60,65, {border=true})
  display(machine.display.next, 150, 70)
end
local love = love

return {

update = function (machine)
    -- buttons: left/level, down/mode, right/speed, rotate/direction, start/pause, on/off, mute
    machine.input.left = love.keyboard.isDown('left')
    machine.input.right = love.keyboard.isDown('right')
    machine.input.down = love.keyboard.isDown('down')
    machine.input.rotate = love.keyboard.isDown('space') or love.keyboard.isDown('up')
end,

keypressed = function(key, os)
  print(key)
  if key == 'escape' then os.reset()
  elseif key == 'p' then os.paused = not os.paused
  elseif key == 'm' then os.muted = not os.muted
  end
end

}
math.randomseed(os.time())

local love = love
local draw = require 'draw'
local input = require 'input'
local machine = require 'machine.machine'
local timer = require 'timer'
local os = require('app.os')(machine)

function love.load()
end

function love.draw()
  draw(machine)
end

local int = timer.interval(1/25, function ()
    if os.paused or machine.gameover then return end
    input.update(machine)
    os.app()
  end)

function love.update(dt)
  int(dt)
end

function love.keypressed(key)
  input.keypressed(key, os)
end
local res = {
  palette = {
    on = {0,0,0},
    off = {171,184,171},
    bg = {181,194,181}
  },

  font = {
    sans = love.graphics.setNewFont('font/digital-graphics-labs_protestant/protest.ttf', 15),
    lcd = love.graphics.setNewFont( 'font/cedders_segment7/Segment7Standard.otf', 32)
  },

  music = {
    --love.audio.newSource('assets/music/03 - Solxis - Rainforest.mp3', 'stream' )
  },
  sfx = {
    --walk = {"106115__j1987__forestwalk.wav", loop=1},
    --land_ch = {"235521__ceberation__landing-on-ground.wav"},
    --land_b = {"136887__animationisaac__box-of-stuff-falls.wav", vol=.2},
  }
}

--res.music[1]:setLooping( true )
--res.music[1]:setVolume(.7)
--res.music[1]:play()

for k, v in pairs(res.sfx) do
  print("Loading sfx", k, v[1])
  v.src = love.audio.newSource( 'assets/sfx/'..v[1], 'static' )
  if v.vol then v.src:setVolume(v.vol) end
  if v.loop then v.src:setLooping(true) end
end

return res
return {
interval = function (machineTick, callback)
  local time=0
  return function (dt)
    time=time+dt
    if time >= machineTick then
      callback()
      time = time - machineTick
      if time > machineTick*10 then
        print('Frame drop', time)
        time = 0
      end
    end
  end
end
}
local Runtime = require 'brick-script.brickscript.runtime'
--TODO move this to brickscript lib
local function read(file) -- TODO should this be here or in client code? At lease allow to pass an ink content in a string
  print("loading", file)
  if love and love.filesystem and love.filesystem.read then
    local content, size = love.filesystem.read(file)
    return content
  else
    local f = io.open(file, "rb")
    if not f then error('failed to open "'..file..'"') end
    local content = f:read("*all")
    f:close()
    return content
  end
end

local load = function (filename)
    local parsed
    if not pcall(function ()
      local req = string.sub(filename, 1, -7) -- without '.brick'
      print('loading precompiled', req)
      parsed = require(req)
    end) then
      print('compiling', filename)
      -- require parser only if previous fails
      local parser  = require 'brick-script.brickscript.parser'
      parsed = parser:match(read(filename))
    end
    return parsed
  end

return {
 load = function(filename, bindings) -- without '.brick'
  local app = load('brick-app/'..filename..'.brick')
  local runtime = Runtime()
  if bindings then for name, value in pairs(bindings) do runtime.assign(name, value) end end
  local appMainLoop = runtime.run(app)
  return appMainLoop
 end
}
local numPos = {2,6}
local brickscript = require "app.brickscript"
local font = brickscript.load('lib/font')

local selected = 1

-- sys apps get os access
return function(os, machine)
 return function()

  -- redraw
  machine.display.main.clear()
  machine.display.main.bitmap(font[selected+1], numPos)

  -- FIXME input
  if machine.input.down then selected = selected+1; if selected > 9 then selected = 1 end end
  if machine.input.rotate then

    local bindings = {
      machine=machine,
      display=machine.display.main,
      displayNext=machine.display.next,
      score=machine.score,
      print=print,
      --draw = require "app.lib.draw",
      ['<'] = function(callback) if machine.input.left then callback() end end,
      ['>'] = function(callback) if machine.input.right then callback() end end,
      ['every'] = function(times)
        local counter = 0
        return function (callback)
          counter = counter + 1
          if counter >= times then
            counter = 0
            callback()
          end
        end
      end,
    }


    machine.display.main.clear()
    os.app=brickscript.load(selected, bindings)
  end

 end
end
local _ = false
local X = true

-- TODO bitmap

local car = {
  {_,X,_},
  {X,X,X},
  {_,X,_},
  {X,_,X},
}

local track = {}



-- TODO vector/pixel/position
local posX = 3
local posY = 16

local time = 0
local move = 0

local drawLine = function (d, x1, y1, x2, y2)
  if x1==x2 then
    for y=y1, y2 do d.on(x1, y) end
  elseif y1==y2 then
    for x=x1, x2 do d.on(x, y1) end
  end
end

local drawBitmap = function (d, map, posX, posY)
  for cy, line in ipairs(map) do
    for cx, val in ipairs(line) do
      if val then d.on(cx-1+posX, cy-1+posY) end
    end
  end
end

local addObstacle = function (obstacle)
  -- TODO helper rectangle, transform
  local line = {}
  for i = 1, obstacle.l do table.insert(line, _) end
  for i = 1, obstacle.w do table.insert(line, X) end
  for i = 1, obstacle.h do table.insert(track, 1, line) end
end


return function(m)

  -- handle input
  if m.input.left then move = -1
  elseif m.input.right then move = 1
  end

  -- do the rest only each 10th tick -- TODO helper function
  time = time+1
  if time%2~=0 then return end

  if time%22==0 then
    local w=math.random(2, 3)
    addObstacle{w=w, h=math.random(2, 3), l=math.random(1, 7)}
    time = 0
    -- TODO timer helpers
    m.score = m.score +1
  else
    table.insert(track, 1, {})
  end

  if #track > m.display.main.h+5 then for i=1, 5 do table.remove(track) end end

  -- update state
  posX = math.max(1, math.min(6, posX + move))
  move = 0

  if track[posY] and track[posY][posX+1] or
     track[posY+1] and track[posY+1][posX] or
     track[posY+1] and track[posY+1][posX+2] then
    m.gameover = true
  end

  -- redraw
  m.display.main.clear()
  drawBitmap(m.display.main, track, 1, 0)
  drawBitmap(m.display.main, car, posX, posY)
  drawBitmap(m.display.next, car, 0, 0)
  drawLine(m.display.main, 0, 0, 0, m.display.main.h)
  drawLine(m.display.main, m.display.main.w-1, 0, m.display.main.w-1, m.display.main.h-1)
end
return function(machine)
    local os = {
      paused = false,
      muted = false,
    }

    local launcher = require('app.launcher')(os, machine)

    os.reset = function()
      os.app=launcher
      machine.score=0
      machine.speed=0
      machine.level=0
      machine.display.next.clear()
      machine.display.main.clear()
      -- etc.. TODO where to put this
    end
    os.reset()
    return os

end
local snake = {{5,15}, {5, 16}, {5, 17}}
local dir = {0,-1}
local food = {5, 10}

local time = 0
return function(g)

  -- handle input
  if g.input.left then dir = {-1, 0} end
  if g.input.right then dir = {1, 0} end
  if g.input.rotate then dir = {0, -1} end
  if g.input.down then dir = {0, 1} end

  -- blink food
  if math.fmod(time, 3)==0 then g.display.main.toggle(food) end

  -- do the rest only each 10th tick
  time = time+1
  if time<10-g.speed then return end
  time = 0

  -- update state
  local head = {snake[1][1]+dir[1], snake[1][2]+dir[2]}
  if head[1]<0 or head[1]>=g.display.main.w or head[2]<0 or head[2]>=g.display.main.h then g.gameover = true; return end
  table.insert(snake, 1, head)

  if head[1]==food[1] and head[2]==food[2] then
    food = {math.random(10)-1, math.random(20)-1}
    g.score = g.score +5
    if g.score > g.speed*10 then g.speed = g.speed +1 end
  else
    table.remove(snake)
  end

  -- redraw
  g.display.main.clear()
  for _, pix in ipairs(snake) do
    g.display.main.on(pix)
  end

end
local _, X = false, true

local bricks = {{
  {X,X},
  {X,X},
}, {
  {X},
  {X},
  {X},
  {X},
}, {
  {_,X},
  {X,X},
  {X,_},
},
}


local brick
local next
local brickPos
local lastBrickMoved


local drawBitmap = function (d, map, pos, onOff)
  for cy, line in ipairs(map) do
    for cx, val in ipairs(line) do
      if val then d.set(cx-1+pos[1], cy-1+pos[2], onOff) end
    end
  end
end

local collision = function (d, map, pos)
  for cy, line in ipairs(map) do
    for cx, val in ipairs(line) do
      local dx, dy = cx-1+pos[1], cy-1+pos[2]
      if val
        and ( d.get(dx, dy)
        or dx>=d.w
        or dx<0
        or dy>=d.h
      ) then return true end
    end
  end
end

local move = function(d, newPos, dir)
  if not collision(d, brick, {newPos[1] + dir, newPos[2]}) then newPos[1] = newPos[1] + dir end
end

local function newBrick()
  brick = next
  next = bricks[math.random(#bricks)]
  if not brick then newBrick() end
  brickPos = {3,0}
end

newBrick()

local time = 0
return function(m)
  time = time+1
  if time<10-m.speed then return end
  time = 0

  local newPos = {brickPos[1], brickPos[2]+1}

  m.display.next.clear()
  drawBitmap(m.display.next, next, {0,0}, X)

  drawBitmap(m.display.main, brick, brickPos, _) -- remove the current brick before collision check

  -- handle input
  if m.input.left then move(m.display.main, newPos, -1) end
  if m.input.right then move(m.display.main, newPos, 1) end
  if m.input.down then end
  if m.input.rotate then  end -- TODO

  if collision(m.display.main, brick, newPos) then
    drawBitmap(m.display.main, brick, brickPos, X) -- put the old brick back
    if not lastBrickMoved then m.gameover = true end
    newBrick()
    lastBrickMoved = false
  else
    lastBrickMoved = true
    brickPos = newPos
    drawBitmap(m.display.main, brick, brickPos, X) -- put the current brick at new pos
  end

end
bricks: [
##
##
,
####
,
##-
-##
,
-##
##-
,
###
#--
,
###
--#
]

startPos: [3, 0]

brick: bricks.random
nextBrick: bricks.random
pos: startPos


display.bitmap(###, [2,3], 2)


redraw: {
  display.clear(1)
  displayNext.clear
  displayNext.bitmap(nextBrick)
  display.bitmap(brick, pos, 1)
}

{
  < {pos << pos.<}
  > {pos << pos.>}
  pos << pos.v

  redraw
}
car:
-#-
###
-#-
#-#

obstacle:
####
####

lives: 3

w: display.w.minus(1)
h: display.h.minus(1)
display.line([0, 0], [0, h], 2)
display.line([w, 0], [w, h], 2)


move: { pos ->
  display.clear(1)
  display.bitmap(car, pos, 1)
}

newLife: {
  displayNext.clear
  displayNext.line([0,0], [0, lives.minus(1)])
  display.clear(10)
}

die: {
  lives << lives.minus(1)
  lives.=(0){ machine.gameover << 1 }
  newLife
}

newLife
move([2, 16])

machine.speed << 1
machine.level << 1

addObstacle: every(20) TODO
forward: every(1)


{
  < {move([2, 16])}
  > {move([5, 16])}

  forward{
    display.shift(0, 1, 10)
    machine.score << machine.score.plus(1)
  }
  addObstacle { display.bitmap(obstacle, [[1,0],[5,0]].random, 10) }
  display.collides(10, 1){die}
}
-- This file was generated by brick-script - do not edit
return {{"assign",{"var","bricks",},{"get",{"list",{{"get",{"bitmap",{{1, 1, },{1, 1, },},},},{"get",{"bitmap",{{1, 1, 1, 1, },},},},{"get",{"bitmap",{{1, 1, 0, },{0, 1, 1, },},},},{"get",{"bitmap",{{0, 1, 1, },{1, 1, 0, },},},},{"get",{"bitmap",{{1, 1, 1, },{1, 0, 0, },},},},{"get",{"bitmap",{{1, 1, 1, },{0, 0, 1, },},},},},},},},{"assign",{"var","startPos",},{"get",{"list",{{"get",{"num","3",},},{"get",{"num","0",},},},},},},{"assign",{"var","brick",},{"get",{"call","bricks",{},},{"call","random",{},},},},{"assign",{"var","nextBrick",},{"get",{"call","bricks",{},},{"call","random",{},},},},{"assign",{"var","pos",},{"get",{"call","startPos",{},},},},{"get",{"call","display",{},},{"call","bitmap",{{"get",{"bitmap",{{1, 1, 1, },},},},{"get",{"list",{{"get",{"num","2",},},{"get",{"num","3",},},},},},{"get",{"num","2",},},},},},{"assign",{"var","redraw",},{"get",{"block",{},{{"get",{"call","display",{},},{"call","clear",{{"get",{"num","1",},},},},},{"get",{"call","displayNext",{},},{"call","clear",{},},},{"get",{"call","displayNext",{},},{"call","bitmap",{{"get",{"call","nextBrick",{},},},},},},{"get",{"call","display",{},},{"call","bitmap",{{"get",{"call","brick",{},},},{"get",{"call","pos",{},},},{"get",{"num","1",},},},},},},},},},{"get",{"block",{},{{"get",{"call","<",{{"block",{},{{"update",{"var","pos",},{"get",{"call","pos",{},},{"call","<",{},},},},},},},},},{"get",{"call",">",{{"block",{},{{"update",{"var","pos",},{"get",{"call","pos",{},},{"call",">",{},},},},},},},},},{"update",{"var","pos",},{"get",{"call","pos",{},},{"call","v",{},},},},{"get",{"call","redraw",{},},},},},},}
-- This file was generated by brick-script - do not edit
return {{"assign",{"var","car",},{"get",{"bitmap",{{0, 1, 0, },{1, 1, 1, },{0, 1, 0, },{1, 0, 1, },},},},},{"assign",{"var","obstacle",},{"get",{"bitmap",{{1, 1, 1, 1, },{1, 1, 1, 1, },},},},},{"assign",{"var","lives",},{"get",{"num","3",},},},{"assign",{"var","w",},{"get",{"call","display",{},},{"call","w",{},},{"call","minus",{{"get",{"num","1",},},},},},},{"assign",{"var","h",},{"get",{"call","display",{},},{"call","h",{},},{"call","minus",{{"get",{"num","1",},},},},},},{"get",{"call","display",{},},{"call","line",{{"get",{"list",{{"get",{"num","0",},},{"get",{"num","0",},},},},},{"get",{"list",{{"get",{"num","0",},},{"get",{"call","h",{},},},},},},{"get",{"num","2",},},},},},{"get",{"call","display",{},},{"call","line",{{"get",{"list",{{"get",{"call","w",{},},},{"get",{"num","0",},},},},},{"get",{"list",{{"get",{"call","w",{},},},{"get",{"call","h",{},},},},},},{"get",{"num","2",},},},},},{"assign",{"var","move",},{"get",{"block",{"pos",},{{"get",{"call","display",{},},{"call","clear",{{"get",{"num","1",},},},},},{"get",{"call","display",{},},{"call","bitmap",{{"get",{"call","car",{},},},{"get",{"call","pos",{},},},{"get",{"num","1",},},},},},},},},},{"assign",{"var","newLife",},{"get",{"block",{},{{"get",{"call","displayNext",{},},{"call","clear",{},},},{"get",{"call","displayNext",{},},{"call","line",{{"get",{"list",{{"get",{"num","0",},},{"get",{"num","0",},},},},},{"get",{"list",{{"get",{"num","0",},},{"get",{"call","lives",{},},{"call","minus",{{"get",{"num","1",},},},},},},},},},},},{"get",{"call","display",{},},{"call","clear",{{"get",{"num","10",},},},},},},},},},{"assign",{"var","die",},{"get",{"block",{},{{"update",{"var","lives",},{"get",{"call","lives",{},},{"call","minus",{{"get",{"num","1",},},},},},},{"get",{"call","lives",{},},{"call","=",{{"get",{"num","0",},},{"block",{},{{"update",{"var",{"call","machine",{},},"gameover",},{"get",{"num","1",},},},},},},},},{"get",{"call","newLife",{},},},},},},},{"get",{"call","newLife",{},},},{"get",{"call","move",{{"get",{"list",{{"get",{"num","2",},},{"get",{"num","16",},},},},},},},},{"update",{"var",{"call","machine",{},},"speed",},{"get",{"num","1",},},},{"update",{"var",{"call","machine",{},},"level",},{"get",{"num","1",},},},{"assign",{"var","addObstacle",},{"get",{"call","every",{{"get",{"num","20",},},},},},},{"task","todo","",},{"assign",{"var","forward",},{"get",{"call","every",{{"get",{"num","1",},},},},},},{"get",{"block",{},{{"get",{"call","<",{{"block",{},{{"get",{"call","move",{{"get",{"list",{{"get",{"num","2",},},{"get",{"num","16",},},},},},},},},},},},},},{"get",{"call",">",{{"block",{},{{"get",{"call","move",{{"get",{"list",{{"get",{"num","5",},},{"get",{"num","16",},},},},},},},},},},},},},{"get",{"call","forward",{{"block",{},{{"get",{"call","display",{},},{"call","shift",{{"get",{"num","0",},},{"get",{"num","1",},},{"get",{"num","10",},},},},},{"update",{"var",{"call","machine",{},},"score",},{"get",{"call","machine",{},},{"call","score",{},},{"call","plus",{{"get",{"num","1",},},},},},},},},},},},{"get",{"call","addObstacle",{{"block",{},{{"get",{"call","display",{},},{"call","bitmap",{{"get",{"call","obstacle",{},},},{"get",{"list",{{"get",{"list",{{"get",{"num","1",},},{"get",{"num","0",},},},},},{"get",{"list",{{"get",{"num","5",},},{"get",{"num","0",},},},},},},},{"call","random",{},},},{"get",{"num","10",},},},},},},},},},},{"get",{"call","display",{},},{"call","collides",{{"get",{"num","10",},},{"get",{"num","1",},},{"block",{},{{"get",{"call","die",{},},},},},},},},},},},}
[
-###-
#---#
#---#
#---#
#---#
#---#
-###-
,
--#--
-##--
--#--
--#--
--#--
--#--
-###-
,
-###-
#---#
----#
---#-
--#--
-#---
#####
,
-###-
#---#
----#
-###-
----#
#---#
-###-
,
---#-
--##-
-#-#-
#--#-
#--#-
#####
---#-
,
#####
#----
####-
----#
----#
#---#
-###-
,
-###-
#---#
#----
####-
#---#
#---#
-###-
,
#####
----#
---#-
--#--
--#--
-#---
-#---
,
-###-
#---#
#---#
-###-
#---#
#---#
-###-
,
-###-
#---#
#---#
-####
----#
#---#
-###-
]
-- This file was generated by brick-script - do not edit
return {{"get",{"list",{{"get",{"bitmap",{{0, 1, 1, 1, 0, },{1, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{0, 1, 1, 1, 0, },},},},{"get",{"bitmap",{{0, 0, 1, 0, 0, },{0, 1, 1, 0, 0, },{0, 0, 1, 0, 0, },{0, 0, 1, 0, 0, },{0, 0, 1, 0, 0, },{0, 0, 1, 0, 0, },{0, 1, 1, 1, 0, },},},},{"get",{"bitmap",{{0, 1, 1, 1, 0, },{1, 0, 0, 0, 1, },{0, 0, 0, 0, 1, },{0, 0, 0, 1, 0, },{0, 0, 1, 0, 0, },{0, 1, 0, 0, 0, },{1, 1, 1, 1, 1, },},},},{"get",{"bitmap",{{0, 1, 1, 1, 0, },{1, 0, 0, 0, 1, },{0, 0, 0, 0, 1, },{0, 1, 1, 1, 0, },{0, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{0, 1, 1, 1, 0, },},},},{"get",{"bitmap",{{0, 0, 0, 1, 0, },{0, 0, 1, 1, 0, },{0, 1, 0, 1, 0, },{1, 0, 0, 1, 0, },{1, 0, 0, 1, 0, },{1, 1, 1, 1, 1, },{0, 0, 0, 1, 0, },},},},{"get",{"bitmap",{{1, 1, 1, 1, 1, },{1, 0, 0, 0, 0, },{1, 1, 1, 1, 0, },{0, 0, 0, 0, 1, },{0, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{0, 1, 1, 1, 0, },},},},{"get",{"bitmap",{{0, 1, 1, 1, 0, },{1, 0, 0, 0, 1, },{1, 0, 0, 0, 0, },{1, 1, 1, 1, 0, },{1, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{0, 1, 1, 1, 0, },},},},{"get",{"bitmap",{{1, 1, 1, 1, 1, },{0, 0, 0, 0, 1, },{0, 0, 0, 1, 0, },{0, 0, 1, 0, 0, },{0, 0, 1, 0, 0, },{0, 1, 0, 0, 0, },{0, 1, 0, 0, 0, },},},},{"get",{"bitmap",{{0, 1, 1, 1, 0, },{1, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{0, 1, 1, 1, 0, },{1, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{0, 1, 1, 1, 0, },},},},{"get",{"bitmap",{{0, 1, 1, 1, 0, },{1, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{0, 1, 1, 1, 1, },{0, 0, 0, 0, 1, },{1, 0, 0, 0, 1, },{0, 1, 1, 1, 0, },},},},},},},}
gitdir: ../../.git/modules/src/brick-script
# Compiled Lua sources
luac.out

# luarocks build files
*.src.rock
*.zip
*.tar.gz

# Object files
*.o
*.os
*.ko
*.obj
*.elf

# Precompiled Headers
*.gch
*.pch

# Libraries
*.lib
*.a
*.la
*.lo
*.def
*.exp

# Shared objects (inc. Windows DLLs)
*.dll
*.so
*.so.*
*.dylib

# Executables
*.exe
*.out
*.app
*.i*86
*.x86_64
*.hex

language: bash
sudo: false
install: true
addons:
  apt:
    packages:
    - lua5.1
    - luarocks
before_install:
  - luarocks install --local lpeg
  - "`luarocks path`" # execute the luarocks output - sets the paths for 'local' tree

script: "./runtests.sh"
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
# Brick Script

A scripting language for writing [Brick Game Machine](https://github.com/premek/brick) games

[![status](https://travis-ci.org/premek/brick-script.svg)](https://travis-ci.org/premek/brick-script)

## Install dependencies
```
$ luarocks install lpeg
```

## Run tests
```
$ ./runtests.sh
```
or
```
$ lua test/parser-simple.lua
$ lua test/parser-complex.lua
$ lua test/runtime.lua
```

## Language (WIP)
```
bricks: [
##
##,
####,
-#
##
#-
]
brickPos: [3,0]
brick: bricks(1)
```

## Integration

```lua
local parser = require('brickscript.parser')
local Runtime = require('brickscript.runtime')

local runtime = Runtime()
runtime.assign('a', 3)
runtime.assign('increase', function(i) return i+1 end)
print("i before execution: ", runtime.get('i'))
local script = [[
  i: increase(a)
  value: 100
  increase(value)
]]
local result = runtime.run(parser:match(script))
print("i after execution: ", runtime.get('i'))
print("result: ", result)
```

```
$ lua examples/usage.lua
i before execution: 	nil
i after execution: 	4
result: 	101
```
#!/usr/bin/env bash

find . -iname "*.lua" | xargs luac -p || { echo 'luac parse test failed' ; exit 1; }

lua test/parser-simple.lua &&
# uncomment when syntax is stable   lua test/parser-complex.lua &&
lua test/runtime.lua &&
echo && echo "ALL OK"

exit $?
local parser = require(arg[0]:match("(.-)[^/\\]+$")..'parser')


local function read(file) -- TODO should this be here or in client code? At lease allow to pass an ink content in a string
  if love and love.filesystem and love.filesystem.read then
    local content, size = love.filesystem.read(file)
    return content
  else
    local f = io.open(file, "rb")
    if not f then error('failed to open "'..file..'"') end
    local content = f:read("*all")
    f:close()
    return content
  end
end


local function dump ( t ) -- tables only (array-like only)
    local function sub_print_r(t)
            if (type(t)=="table") then
                local b = ""
                for pos,val in pairs(t) do
                    if (type(val)=="table") then
                        b = b .. "{"..sub_print_r(val).."},"
                    elseif (type(val)=="string") then
                        b = b .. '"'..string.gsub(val,'"', '\\"')..'",'
                    else
                        b = b .. tostring(val) .. ', '
                    end
                end
                return b
            else
                return tostring(t)
            end
    end
    return "-- This file was generated by brick-script - do not edit\nreturn {" .. sub_print_r(t) .. "}"
end

print(dump(parser:match(read(arg[1]))))
local lpeg = require "lpeg"

lpeg.locale(lpeg)
local S,C,Ct,Cc,Cg,Cb,Cf,Cmt,Cp,P,V =
  lpeg.S, lpeg.C, lpeg.Ct, lpeg.Cc, lpeg.Cg, lpeg.Cb, lpeg.Cf, lpeg.Cmt, lpeg.Cp,
  lpeg.P, lpeg.V


local eof = -1
local sp = S" \t" ^0 + eof
local wh = S" \t\r\n" ^0 + eof
local nl = S"\r\n" ^1 + eof

local dig = lpeg.digit
local symbols = S":{}()[],. \t\r\n"
local idFirstNotAllowed = symbols+dig+S'#-'
local id = C((1-idFirstNotAllowed)*(1-symbols)^0)*sp
local num = Ct(Cc"num" * C(dig^1)) *sp -- do we really need you? :)
local fnParams = Ct(Cc"params" * "(" * wh * (id * (P"," * wh * id)^0)^0 *wh* ")") *sp -- not needed?
local blockParams = wh * Ct((id * (wh * "," * wh * id)^0 *wh*'->')^0) *wh
local argSep = P","*wh

local codeTaskType = (P"TODO" + P"FIXME" + P"XXX")/string.lower
local codeTask = Ct(Cc"task" * codeTaskType * sp * C((P(1)-nl)^0))*nl
local commentLine = P"//"*((P(1)-nl)^0)*nl
local commentBlock = P"/*" * ((P(1)-"*/")^0)*"*/"*wh
local comment = commentLine + commentBlock

local bit = S"#-" / function(str) return str=="#" and 1 or 0 end
local bitmap = Ct(Cc"bitmap" * Ct(Ct(sp * bit^1 * wh)^1))

local g = P({
 "prog",
 prog = wh* Ct(V'stmt'^0),
 stmt = (comment + codeTask + V'fn' + V'assign' + V'update'  + V'get')*wh,

 list = Ct(Cc"list" * P"[" * wh * argSep^-1 * Ct((V'stmt' * (P"," * wh * V'stmt')^0 * (wh*','*wh)^-1)^-1) * "]"),
 block = Ct(P"{"/"block" * blockParams * Ct((V'stmt')^0) * "}"),
 fn = Ct(Cc"fn" * fnParams * wh * V'stmt'), -- FIXME not needed? see block/lambda?

 value = (V'call'+V'block'+V'list'+num+bitmap),
 callArgs =  Ct(("(" * wh *( argSep^-1 * V'stmt' * (argSep * wh * V'stmt' )^0 * argSep^-1)^-1* ")")^-1 * sp * V'block'^-1 )*wh,
 get = Ct(Cc'get' * V'value' * V'callOnValue'),
 call  = Ct(Cc'call'*id * V'callArgs'),
 callOnValue  = ('.' * V'call' * V'callOnValue')^-1,

 var = Ct(Cc'var' * (V'value' * '.')^0 * id),
 assign = Ct(Cc"assign" * V'var' * ":" * wh * V'stmt'),
 update = Ct(Cc"update" * V'var' * "<<" * wh * V'stmt'),

})

return g;
math.randomseed(os.time())

return function()

local runNode, runTree

local global = {}

local isVector = function (o) return type(o) == 'table' and #o==2 and type(o[1]) == 'number' and type(o[2]) == 'number' end

local call = function(n, callOn, scope)
  local varName = n[2]
  local arguments = {}
  for i,argument in ipairs(n[3]) do
    arguments[i] = runNode(argument, scope)
  end
  local called
  -- TODO clean up
  if type(callOn) == 'number' and varName =='plus' then called = function (num) return callOn+num end
  elseif type(callOn) == 'number' and varName =='minus' then called = function (num) return callOn-num end
  elseif type(callOn) == 'number' and varName =='times' and type(arguments[1])=='function' then called = function (cb) for i=1,callOn do cb(i-1) end end
  elseif type(callOn) == 'number' and varName =='>' then called = function (other, cb) if callOn>other then return cb() end end
  elseif type(callOn) == 'number' and varName =='<' then called = function (other, cb) if callOn<other then return cb() end end
  elseif type(callOn) == 'number' and varName =='>=' then called = function (other, cb) if callOn>=other then return cb() end end
  elseif type(callOn) == 'number' and varName =='<=' then called = function (other, cb) if callOn<=other then return cb() end end
  elseif type(callOn) == 'number' and varName =='=' then called = function (other, cb) if callOn==other then return cb() end end
  elseif type(callOn) == 'table' and varName =='random' then called = function () return callOn[math.random(#callOn)] end
  elseif type(callOn) == 'table' and varName =='size' then called = function() return #callOn end
  elseif type(callOn) == 'table' and varName =='isEmpty' then called = function() return #callOn==0 end
  elseif isVector(callOn) and varName =='x' then called = function() return callOn[1] end
  elseif isVector(callOn) and varName =='y' then called = function() return callOn[2] end
  elseif isVector(callOn) and varName =='<' then called = function(i) return {callOn[1]-(i or 1), callOn[2]} end
  elseif isVector(callOn) and varName =='>' then called = function(i) return {callOn[1]+(i or 1), callOn[2]} end
  elseif isVector(callOn) and varName =='^' then called = function(i) return {callOn[1], callOn[2]-(i or 1)} end
  elseif isVector(callOn) and varName =='v' then called = function(i) return {callOn[1], callOn[2]+(i or 1)} end

  else
    print('call', varName, 'on', scope)
    called = callOn[varName]
    print('call res', called)
    while(not called and callOn['_parent']) do
      callOn = callOn['_parent']
      called = callOn[varName]
      print('called on parent', callOn, called)
    end
  end
  local calledType = type(called)
  print('call', varName, #arguments, calledType, called, 'on', callOn)
  if calledType == 'function' then
      -- fn call
      return called(unpack(arguments)) end
  if calledType == 'table' and #arguments == 1 and type(arguments[1]=='number') then
      -- list access
      -- TODO 0 or 1 based indexing
      -- TODO out of bounds
      return called[arguments[1]+1] end
  return called -- get variable value
end



local var = function(n, scope, tryParents)
  print('var')
  local callOn = scope
  local varName = n[#n]
  for i=2, #n-1 do
    if(n[i][1]=='call') then
      callOn = call(n[i], callOn, scope)
    else
      callOn = runNode(n[i], callOn)
    end
  end
  while tryParents and not callOn[varName] and callOn['_parent'] do
    callOn = callOn['_parent']
    print('parent', callOn)
  end
  return callOn, varName
end

local defaultTaskHandlers = {
  -- TODO logging framework
  todo = function(msg) print("TODO", msg) end,
  fixme = function(msg) print("FIXME", msg) end,
  xxx = function(msg) print("XXX", msg) end,
}

local nodeRunners
nodeRunners = {

  assign = function(n, scope)
    local callOn, varName = var(n[2], scope, false)
    print ('assign', varName)
    callOn[varName] = runNode(n[3], scope)
    print ('assign', varName, callOn[varName])
    return callOn[varName]
  end,

  update = function(n, scope)
    local callOn, varName = var(n[2], scope, true)
    print ('update', varName, callOn)
    callOn[varName] = runNode(n[3], scope)
    print ('update', varName, callOn[varName])
    return callOn[varName]
  end,

  num = function(n, scope)
    print('num', n[2])
    return tonumber(n[2])
  end,

  list = function(n, scope)
    local res = {}
    for i,argument in ipairs(n[2]) do
      res[i] = runNode(argument, scope)
    end
    print('list', '#: ', #res, res)
    return res
  end,

  bitmap = function(n, scope)
    local res = n[2]
    res['h']=#res
    res['w']=0
    for i=1, #res do if #res[i]>res['w'] then res['w']=#res[i] end end
    return res
  end,

  block = function(n, scope)
    local localScope = {_parent = scope} -- TODO parent scope / prototype
    local paramNamesByOrder = n[2]
    local blockBody = n[3]
    return function(...)
      local arg={...}
      print('run block', #arg, 'scope', localScope, 'params', arg[1], arg[2])
      for paramOrder, paramValue in ipairs(arg) do
        local paramName = paramNamesByOrder[paramOrder]
        if paramName ~= nil then
          localScope[paramName] = paramValue
        end
      end
     return runTree(blockBody, 1, localScope)
    end
  end,

  get = function(n, scope)
    print('get')
    local callOn = scope
    local lastVal
    for i=2, #n do -- FIXME clean, duplicated code
      if(n[i][1]=='call') then
        lastVal = call(n[i], callOn, scope)
      else
        lastVal = runNode(n[i], callOn)
      end
      print('call res', lastVal)
      callOn = lastVal
    end
    print('get got', lastVal)
    return lastVal
  end,

  task = function(n, scope)
    print('task', n[2], n[3])
    local handler = (global.task and global.task[n[2]]) or defaultTaskHandlers[n[2]]
    handler(n[3])
  end,


}

runNode = function(n, scope)
  local type = n[1]
  print('node', type, 'scope', scope)

  return nodeRunners[type](n, scope)
end

runTree = function(tree, from, scope)
  print('runTree', 'scope', scope)
  local n = tree[from]
  -- TODO Void or Unit or Nothing ?
  if n~=nil then
    local firstResult = runNode(n, scope)
    if #tree == from then return firstResult
    else
      print('-----')
      return runTree(tree, from+1, scope)
    end
  end
end


-- public API

return {
  -- FIXME API to run string script directly without the need to call parser from client code
  run = function(tree)
    return runTree(tree, 1, global)
  end,

  assign = function(varName, value)
    global[varName] = value
  end,

  get = function(varName)
    return global[varName]
  end,
}
end
local parser = require('brickscript.parser')
local Runtime = require('brickscript.runtime')

local runtime = Runtime()
runtime.assign('a', 3)
runtime.assign('increase', function(i) return i+1 end)
print("i before execution: ", runtime.get('i'))
local script = [[
  i: increase(a)
  value: 100
  increase(value)
]]
local result = runtime.run(parser:match(script))
print("i after execution: ", runtime.get('i'))
print("result: ", result)
--[[
        luaunit.lua

Description: A unit testing framework
Homepage: https://github.com/bluebird75/luaunit
Development by Philippe Fremy <phil@freehackers.org>
Based on initial work of Ryu, Gwang (http://www.gpgstudy.com/gpgiki/LuaUnit)
License: BSD License, see LICENSE.txt
Version: 3.2
]]--

require("math")
local M={}

-- private exported functions (for testing)
M.private = {}

M.VERSION='3.2'
M._VERSION=M.VERSION -- For LuaUnit v2 compatibility

--[[ Some people like assertEquals( actual, expected ) and some people prefer 
assertEquals( expected, actual ).
]]--
M.ORDER_ACTUAL_EXPECTED = true
M.PRINT_TABLE_REF_IN_ERROR_MSG = false
M.TABLE_EQUALS_KEYBYCONTENT = true
M.LINE_LENGTH=80

-- set this to false to debug luaunit
local STRIP_LUAUNIT_FROM_STACKTRACE=true

M.VERBOSITY_DEFAULT = 10
M.VERBOSITY_LOW     = 1
M.VERBOSITY_QUIET   = 0
M.VERBOSITY_VERBOSE = 20

-- set EXPORT_ASSERT_TO_GLOBALS to have all asserts visible as global values
-- EXPORT_ASSERT_TO_GLOBALS = true

-- we need to keep a copy of the script args before it is overriden
local cmdline_argv = rawget(_G, "arg")

M.FAILURE_PREFIX = 'LuaUnit test FAILURE: ' -- prefix string for failed tests

M.USAGE=[[Usage: lua <your_test_suite.lua> [options] [testname1 [testname2] ... ]
Options:
  -h, --help:             Print this help
  --version:              Print version information
  -v, --verbose:          Increase verbosity
  -q, --quiet:            Set verbosity to minimum
  -e, --error:            Stop on first error
  -f, --failure:          Stop on first failure or error
  -o, --output OUTPUT:    Set output type to OUTPUT
                          Possible values: text, tap, junit, nil
  -n, --name NAME:        For junit only, mandatory name of xml file
  -p, --pattern PATTERN:  Execute all test names matching the Lua PATTERN
                          May be repeated to include severals patterns
                          Make sure you escape magic chars like +? with %
  testname1, testname2, ... : tests to run in the form of testFunction,
                              TestClass or TestClass.testMethod
]]

----------------------------------------------------------------
--
--                 general utility functions
--
----------------------------------------------------------------

local crossTypeOrdering = {
    number = 1,
    boolean = 2,
    string = 3,
    table = 4,
    other = 5
}
local crossTypeComparison = {
    number = function(a, b) return a < b end,
    string = function(a, b) return a < b end,
    other = function(a, b) return tostring(a) < tostring(b) end,
}

local function crossTypeSort(a, b)
    local type_a, type_b = type(a), type(b)
    if type_a == type_b then
        local func = crossTypeComparison[type_a] or crossTypeComparison.other
        return func(a, b)
    end
    type_a = crossTypeOrdering[type_a] or crossTypeOrdering.other
    type_b = crossTypeOrdering[type_b] or crossTypeOrdering.other
    return type_a < type_b
end

local function __genSortedIndex( t )
    -- Returns a sequence consisting of t's keys, sorted.
    local sortedIndex = {}

    for key,_ in pairs(t) do
        table.insert(sortedIndex, key)
    end

    table.sort(sortedIndex, crossTypeSort)
    return sortedIndex
end
M.private.__genSortedIndex = __genSortedIndex

local function sortedNext(state, control)
    -- Equivalent of the next() function of table iteration, but returns the
    -- keys in sorted order (see __genSortedIndex and crossTypeSort).
    -- The state is a temporary variable during iteration and contains the
    -- sorted key table (state.sortedIdx). It also stores the last index (into
    -- the keys) used by the iteration, to find the next one quickly.
    local key

    --print("sortedNext: control = "..tostring(control) )
    if control == nil then
        -- start of iteration
        state.lastIdx = 1
        key = state.sortedIdx[1]
        return key, state.t[key]
    end

    -- normally, we expect the control variable to match the last key used
    if control ~= state.sortedIdx[state.lastIdx] then
        -- strange, we have to find the next value by ourselves
        -- the key table is sorted in crossTypeSort() order! -> use bisection
        local count = #state.sortedIdx
        local lower, upper = 1, count
        repeat
            state.lastIdx = math.modf((lower + upper) / 2)
            key = state.sortedIdx[state.lastIdx]
            if key == control then break; end -- key found (and thus prev index)
            if crossTypeSort(key, control) then
                -- key < control, continue search "right" (towards upper bound)
                lower = state.lastIdx + 1
            else
                -- key > control, continue search "left" (towards lower bound)
                upper = state.lastIdx - 1
            end
        until lower > upper
        if lower > upper then -- only true if the key wasn't found, ...
            state.lastIdx = count -- ... so ensure no match for the code below
        end
    end

    -- proceed by retrieving the next value (or nil) from the sorted keys
    state.lastIdx = state.lastIdx + 1
    key = state.sortedIdx[state.lastIdx]
    if key then
        return key, state.t[key]
    end

    -- getting here means returning `nil`, which will end the iteration
end

local function sortedPairs(tbl)
    -- Equivalent of the pairs() function on tables. Allows to iterate in
    -- sorted order. As required by "generic for" loops, this will return the
    -- iterator (function), an "invariant state", and the initial control value.
    -- (see http://www.lua.org/pil/7.2.html)
    return sortedNext, {t = tbl, sortedIdx = __genSortedIndex(tbl)}, nil
end
M.private.sortedPairs = sortedPairs

local function strsplit(delimiter, text)
-- Split text into a list consisting of the strings in text, separated
-- by strings matching delimiter (which may _NOT_ be a pattern).
-- Example: strsplit(", ", "Anna, Bob, Charlie, Dolores")
    if delimiter == "" then -- this would result in endless loops
        error("delimiter matches empty string!")
    end
    local list, pos, first, last = {}, 1
    while true do
        first, last = text:find(delimiter, pos, true)
        if first then -- found?
            table.insert(list, text:sub(pos, first - 1))
            pos = last + 1
        else
            table.insert(list, text:sub(pos))
            break
        end
    end
    return list
end
M.private.strsplit = strsplit

local function hasNewLine( s )
    -- return true if s has a newline
    return (string.find(s, '\n', 1, true) ~= nil)
end
M.private.hasNewLine = hasNewLine

local function prefixString( prefix, s )
    -- Prefix all the lines of s with prefix
    return prefix .. string.gsub(s, '\n', '\n' .. prefix)
end
M.private.prefixString = prefixString

local function strMatch(s, pattern, start, final )
    -- return true if s matches completely the pattern from index start to index end
    -- return false in every other cases
    -- if start is nil, matches from the beginning of the string
    -- if final is nil, matches to the end of the string
    start = start or 1
    final = final or string.len(s)

    local foundStart, foundEnd = string.find(s, pattern, start, false)
    return foundStart == start and foundEnd == final
end
M.private.strMatch = strMatch

local function xmlEscape( s )
    -- Return s escaped for XML attributes
    -- escapes table:
    -- "   &quot;
    -- '   &apos;
    -- <   &lt;
    -- >   &gt;
    -- &   &amp;

    return string.gsub( s, '.', {
        ['&'] = "&amp;",
        ['"'] = "&quot;",
        ["'"] = "&apos;",
        ['<'] = "&lt;",
        ['>'] = "&gt;",
    } )
end
M.private.xmlEscape = xmlEscape

local function xmlCDataEscape( s )
    -- Return s escaped for CData section, escapes: "]]>"
    return string.gsub( s, ']]>', ']]&gt;' )
end
M.private.xmlCDataEscape = xmlCDataEscape

local function stripLuaunitTrace( stackTrace )
    --[[
    -- Example of  a traceback:
    <<stack traceback:
        example_with_luaunit.lua:130: in function 'test2_withFailure'
        ./luaunit.lua:1449: in function <./luaunit.lua:1449>
        [C]: in function 'xpcall'
        ./luaunit.lua:1449: in function 'protectedCall'
        ./luaunit.lua:1508: in function 'execOneFunction'
        ./luaunit.lua:1596: in function 'runSuiteByInstances'
        ./luaunit.lua:1660: in function 'runSuiteByNames'
        ./luaunit.lua:1736: in function 'runSuite'
        example_with_luaunit.lua:140: in main chunk
        [C]: in ?>>

        Other example:
    <<stack traceback:
        ./luaunit.lua:545: in function 'assertEquals'
        example_with_luaunit.lua:58: in function 'TestToto.test7'
        ./luaunit.lua:1517: in function <./luaunit.lua:1517>
        [C]: in function 'xpcall'
        ./luaunit.lua:1517: in function 'protectedCall'
        ./luaunit.lua:1578: in function 'execOneFunction'
        ./luaunit.lua:1677: in function 'runSuiteByInstances'
        ./luaunit.lua:1730: in function 'runSuiteByNames'
        ./luaunit.lua:1806: in function 'runSuite'
        example_with_luaunit.lua:140: in main chunk
        [C]: in ?>>

    <<stack traceback:
        luaunit2/example_with_luaunit.lua:124: in function 'test1_withFailure'
        luaunit2/luaunit.lua:1532: in function <luaunit2/luaunit.lua:1532>
        [C]: in function 'xpcall'
        luaunit2/luaunit.lua:1532: in function 'protectedCall'
        luaunit2/luaunit.lua:1591: in function 'execOneFunction'
        luaunit2/luaunit.lua:1679: in function 'runSuiteByInstances'
        luaunit2/luaunit.lua:1743: in function 'runSuiteByNames'
        luaunit2/luaunit.lua:1819: in function 'runSuite'
        luaunit2/example_with_luaunit.lua:140: in main chunk
        [C]: in ?>>


    -- first line is "stack traceback": KEEP
    -- next line may be luaunit line: REMOVE
    -- next lines are call in the program under testOk: REMOVE
    -- next lines are calls from luaunit to call the program under test: KEEP

    -- Strategy:
    -- keep first line
    -- remove lines that are part of luaunit
    -- kepp lines until we hit a luaunit line
    ]]

    local function isLuaunitInternalLine( s )
        -- return true if line of stack trace comes from inside luaunit
        return s:find('[/\\]luaunit%.lua:%d+: ') ~= nil
    end

    -- print( '<<'..stackTrace..'>>' )

    local t = strsplit( '\n', stackTrace )
    -- print( prettystr(t) )

    local idx = 2

    -- remove lines that are still part of luaunit
    while t[idx] and isLuaunitInternalLine( t[idx] ) do
        -- print('Removing : '..t[idx] )
        table.remove(t, idx)
    end

    -- keep lines until we hit luaunit again
    while t[idx] and (not isLuaunitInternalLine(t[idx])) do
        -- print('Keeping : '..t[idx] )
        idx = idx + 1
    end

    -- remove remaining luaunit lines
    while t[idx] do
        -- print('Removing : '..t[idx] )
        table.remove(t, idx)
    end

    -- print( prettystr(t) )
    return table.concat( t, '\n')

end
M.private.stripLuaunitTrace = stripLuaunitTrace


local function prettystr_sub(v, indentLevel, keeponeline, printTableRefs, recursionTable )
    local type_v = type(v)
    if "string" == type_v  then
        if keeponeline then v = v:gsub("\n", "\\n") end

        -- use clever delimiters according to content:
        -- enclose with single quotes if string contains ", but no '
        if v:find('"', 1, true) and not v:find("'", 1, true) then
            return "'" .. v .. "'"
        end
        -- use double quotes otherwise, escape embedded "
        return '"' .. v:gsub('"', '\\"') .. '"'

    elseif "table" == type_v then
        --if v.__class__ then
        --    return string.gsub( tostring(v), 'table', v.__class__ )
        --end
        return M.private._table_tostring(v, indentLevel, printTableRefs, recursionTable)
    end

    return tostring(v)
end

local function prettystr( v, keeponeline )
    --[[ Better string conversion, to display nice variable content:
    For strings, if keeponeline is set to true, string is displayed on one line, with visible \n
    * string are enclosed with " by default, or with ' if string contains a "
    * if table is a class, display class name
    * tables are expanded
    ]]--
    local recursionTable = {}
    local s = prettystr_sub(v, 1, keeponeline, M.PRINT_TABLE_REF_IN_ERROR_MSG, recursionTable)
    if recursionTable.recursionDetected and not M.PRINT_TABLE_REF_IN_ERROR_MSG then
        -- some table contain recursive references,
        -- so we must recompute the value by including all table references
        -- else the result looks like crap
        recursionTable = {}
        s = prettystr_sub(v, 1, keeponeline, true, recursionTable)
    end
    return s
end
M.prettystr = prettystr

local function prettystrPadded(value1, value2, suffix_a, suffix_b)
    --[[
    This function helps with the recurring task of constructing the "expected
    vs. actual" error messages. It takes two arbitrary values and formats
    corresponding strings with prettystr().

    To keep the (possibly complex) output more readable in case the resulting
    strings contain line breaks, they get automatically prefixed with additional
    newlines. Both suffixes are optional (default to empty strings), and get
    appended to the "value1" string. "suffix_a" is used if line breaks were
    encountered, "suffix_b" otherwise.

    Returns the two formatted strings (including padding/newlines).
    ]]
    local str1, str2 = prettystr(value1), prettystr(value2)
    if hasNewLine(str1) or hasNewLine(str2) then
        -- line break(s) detected, add padding
        return "\n" .. str1 .. (suffix_a or ""), "\n" .. str2
    end
    return str1 .. (suffix_b or ""), str2
end
M.private.prettystrPadded = prettystrPadded

local function _table_keytostring(k)
    -- like prettystr but do not enclose with "" if the string is just alphanumerical
    -- this is better for displaying table keys who are often simple strings
    if "string" == type(k) and k:match("^[_%a][_%w]*$") then
        return k
    end
    return prettystr(k)
end
M.private._table_keytostring = _table_keytostring

local TABLE_TOSTRING_SEP = ", "
local TABLE_TOSTRING_SEP_LEN = string.len(TABLE_TOSTRING_SEP)

local function _table_tostring( tbl, indentLevel, printTableRefs, recursionTable )
    printTableRefs = printTableRefs or M.PRINT_TABLE_REF_IN_ERROR_MSG
    recursionTable = recursionTable or {}
    recursionTable[tbl] = true

    local result, dispOnMultLines = {}, false

    local entry, count, seq_index = nil, 0, 1
    for k, v in sortedPairs( tbl ) do
        if k == seq_index then
            -- for the sequential part of tables, we'll skip the "<key>=" output
            entry = ''
            seq_index = seq_index + 1
        else
            entry = _table_keytostring( k ) .. "="
        end
        if recursionTable[v] then -- recursion detected!
            recursionTable.recursionDetected = true
            entry = entry .. "<"..tostring(v)..">"
        else
            entry = entry ..
                prettystr_sub( v, indentLevel+1, true, printTableRefs, recursionTable )
        end
        count = count + 1
        result[count] = entry
    end

    -- set dispOnMultLines if the maximum LINE_LENGTH would be exceeded
    local totalLength = 0
    for k, v in ipairs( result ) do
        totalLength = totalLength + string.len( v )
        if totalLength >= M.LINE_LENGTH then
            dispOnMultLines = true
            break
        end
    end

    if not dispOnMultLines then
        -- adjust with length of separator(s):
        -- two items need 1 sep, three items two seps, ... plus len of '{}'
        if count > 0 then
            totalLength = totalLength + TABLE_TOSTRING_SEP_LEN * (count - 1)
        end
        dispOnMultLines = totalLength + 2 >= M.LINE_LENGTH
    end

    -- now reformat the result table (currently holding element strings)
    if dispOnMultLines then
        local indentString = string.rep("    ", indentLevel - 1)
        result = {"{\n    ", indentString,
                  table.concat(result, ",\n    " .. indentString), "\n",
                  indentString, "}"}
    else
        result = {"{", table.concat(result, TABLE_TOSTRING_SEP), "}"}
    end
    if printTableRefs then
        table.insert(result, 1, "<"..tostring(tbl).."> ") -- prepend table ref
    end
    return table.concat(result)
end
M.private._table_tostring = _table_tostring -- prettystr_sub() needs it

local function _table_contains(t, element)
    if type(t) == "table" then
        local type_e = type(element)
        for _, value in pairs(t) do
            if type(value) == type_e then
                if value == element then
                    return true
                end
                if type_e == 'table' then
                    -- if we wanted recursive items content comparison, we could use
                    -- _is_table_items_equals(v, expected) but one level of just comparing
                    -- items is sufficient
                    if M.private._is_table_equals( value, element ) then
                        return true
                    end
                end
            end
        end
    end
    return false
end

local function _is_table_items_equals(actual, expected )
    local type_a, type_e = type(actual), type(expected)

    if (type_a == 'table') and (type_e == 'table') then
        for k, v in pairs(actual) do
            if not _table_contains(expected, v) then
                return false
            end
        end
        for k, v in pairs(expected) do
            if not _table_contains(actual, v) then
                return false
            end
        end
        return true

    elseif type_a ~= type_e then
        return false

    elseif actual ~= expected then
        return false
    end

    return true
end

local function _is_table_equals(actual, expected, recursions)
    local type_a, type_e = type(actual), type(expected)
    recursions = recursions or {}

    if type_a ~= type_e then
        return false -- different types won't match
    end

    if (type_a == 'table') --[[ and (type_e == 'table') ]] and not recursions[actual] then
        -- Tables must have identical element count, or they can't match.
        if (#actual ~= #expected) then
            return false
        end

        -- add "actual" to the recursions table, to detect and avoid loops
        recursions[actual] = true

        local actualKeysMatched, actualTableKeys = {}, {}

        for k, v in pairs(actual) do
            if M.TABLE_EQUALS_KEYBYCONTENT and type(k) == "table" then
                -- If the keys are tables, things get a bit tricky here as we
                -- can have _is_table_equals(k1, k2) and t[k1] ~= t[k2]. So we
                -- collect actual's table keys, group them by length for
                -- performance, and then for each table key in expected we look
                -- it up in actualTableKeys.
                local count = #k
                if not actualTableKeys[count] then actualTableKeys[count] = {} end
                table.insert(actualTableKeys[count], k)
            else
                if not _is_table_equals(v, expected[k], recursions) then
                    return false -- Mismatch on value, tables can't be equal
                end
                actualKeysMatched[k] = true -- Keep track of matched keys
            end
        end

        for k, v in pairs(expected) do
            if M.TABLE_EQUALS_KEYBYCONTENT and type(k) == "table" then
                local candidates, found = actualTableKeys[#k], nil
                if not candidates then return false end
                for i, candidate in pairs(candidates) do
                    if _is_table_equals(candidate, k) then
                        found = candidate
                        -- Remove the candidate we matched against from the list
                        -- of candidates, so each key in actual can only match
                        -- one key in expected.
                        candidates[i] = nil
                        break
                    end
                end
                if not(found and _is_table_equals(actual[found], v)) then
                    -- Either no matching key, or a different value
                    return false
                end
            else
                if not actualKeysMatched[k] then
                    -- Found a key that we did not see in "actual" -> mismatch
                    return false
                end
                -- Otherwise we know that actual[k] was already matched
                -- against v = expected[k]. Remove k from the table again.
                actualKeysMatched[k] = nil
            end
        end

        -- If we have any keys left in the actualKeysMatched table, then those
        -- were missing from "expected", meaning the tables are different.
        if next(actualKeysMatched) then return false end

        if M.TABLE_EQUALS_KEYBYCONTENT then
            for _, keys in pairs(actualTableKeys) do
                -- if there are any keys left in any actualTableKeys[i] then
                -- that is a key in actual with no matching key in expected,
                -- and so the tables aren't equal.
                if next(keys) then return false end
            end
        end

        return true

    elseif actual ~= expected then
        return false
    end

    return true
end
M.private._is_table_equals = _is_table_equals

local function failure(msg, level)
    -- raise an error indicating a test failure
    -- for error() compatibility we adjust "level" here (by +1), to report the
    -- calling context
    error(M.FAILURE_PREFIX .. msg, (level or 1) + 1)
end

local function fail_fmt(level, ...)
     -- failure with printf-style formatted message and given error level
    failure(string.format(...), (level or 1) + 1)
end
M.private.fail_fmt = fail_fmt

local function error_fmt(level, ...)
     -- printf-style error()
    error(string.format(...), (level or 1) + 1)
end

----------------------------------------------------------------
--
--                     assertions
--
----------------------------------------------------------------

local function errorMsgEquality(actual, expected)
    if not M.ORDER_ACTUAL_EXPECTED then
        expected, actual = actual, expected
    end
    if type(expected) == 'string' or type(expected) == 'table' then
        expected, actual = prettystrPadded(expected, actual)
        return string.format("expected: %s\nactual: %s", expected, actual)
    end
    return string.format("expected: %s, actual: %s",
                         prettystr(expected), prettystr(actual))
end

function M.assertError(f, ...)
    -- assert that calling f with the arguments will raise an error
    -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
    if pcall( f, ... ) then
        failure( "Expected an error when calling function but no error generated", 2 )
    end
end

function M.assertTrue(value)
    if not value then
        failure("expected: true, actual: " ..prettystr(value), 2)
    end
end

function M.assertFalse(value)
    if value then
        failure("expected: false, actual: " ..prettystr(value), 2)
    end
end

function M.assertIsNil(value)
    if value ~= nil then
        failure("expected: nil, actual: " ..prettystr(value), 2)
    end
end

function M.assertNotIsNil(value)
    if value == nil then
        failure("expected non nil value, received nil", 2)
    end
end

function M.assertEquals(actual, expected)
    if type(actual) == 'table' and type(expected) == 'table' then
        if not _is_table_equals(actual, expected) then
            failure( errorMsgEquality(actual, expected), 2 )
        end
    elseif type(actual) ~= type(expected) then
        failure( errorMsgEquality(actual, expected), 2 )
    elseif actual ~= expected then
        failure( errorMsgEquality(actual, expected), 2 )
    end
end

-- Help Lua in corner cases like almostEquals(1.1, 1.0, 0.1), which by default
-- may not work. We need to give margin a small boost; EPSILON defines the
-- default value to use for this:
local EPSILON = 1E-11
function M.almostEquals( actual, expected, margin, margin_boost )
    if type(actual) ~= 'number' or type(expected) ~= 'number' or type(margin) ~= 'number' then
        error_fmt(3, 'almostEquals: must supply only number arguments.\nArguments supplied: %s, %s, %s',
            prettystr(actual), prettystr(expected), prettystr(margin))
    end
    if margin < 0 then
        error('almostEquals: margin must not be negative, current value is ' .. margin, 3)
    end
    local realmargin = margin + (margin_boost or EPSILON)
    return math.abs(expected - actual) <= realmargin
end

function M.assertAlmostEquals( actual, expected, margin )
    -- check that two floats are close by margin
    if not M.almostEquals(actual, expected, margin) then
        if not M.ORDER_ACTUAL_EXPECTED then
            expected, actual = actual, expected
        end
        fail_fmt(2, 'Values are not almost equal\nExpected: %s with margin of %s, received: %s',
                 expected, margin, actual)
    end
end

function M.assertNotEquals(actual, expected)
    if type(actual) ~= type(expected) then
        return
    end

    if type(actual) == 'table' and type(expected) == 'table' then
        if not _is_table_equals(actual, expected) then
            return
        end
    elseif actual ~= expected then
        return
    end
    fail_fmt(2, 'Received the not expected value: %s', prettystr(actual))
end

function M.assertNotAlmostEquals( actual, expected, margin )
    -- check that two floats are not close by margin
    if M.almostEquals(actual, expected, margin) then
        if not M.ORDER_ACTUAL_EXPECTED then
            expected, actual = actual, expected
        end
        fail_fmt(2, 'Values are almost equal\nExpected: %s with a difference above margin of %s, received: %s',
                 expected, margin, actual)
    end
end

function M.assertStrContains( str, sub, useRe )
    -- this relies on lua string.find function
    -- a string always contains the empty string
    if not string.find(str, sub, 1, not useRe) then
        sub, str = prettystrPadded(sub, str, '\n')
        fail_fmt(2, 'Error, %s %s was not found in string %s',
                 useRe and 'regexp' or 'substring', sub, str)
    end
end

function M.assertStrIContains( str, sub )
    -- this relies on lua string.find function
    -- a string always contains the empty string
    if not string.find(str:lower(), sub:lower(), 1, true) then
        sub, str = prettystrPadded(sub, str, '\n')
        fail_fmt(2, 'Error, substring %s was not found (case insensitively) in string %s',
                 sub, str)
    end
end

function M.assertNotStrContains( str, sub, useRe )
    -- this relies on lua string.find function
    -- a string always contains the empty string
    if string.find(str, sub, 1, not useRe) then
        sub, str = prettystrPadded(sub, str, '\n')
        fail_fmt(2, 'Error, %s %s was found in string %s',
                 useRe and 'regexp' or 'substring', sub, str)
    end
end

function M.assertNotStrIContains( str, sub )
    -- this relies on lua string.find function
    -- a string always contains the empty string
    if string.find(str:lower(), sub:lower(), 1, true) then
        sub, str = prettystrPadded(sub, str, '\n')
        fail_fmt(2, 'Error, substring %s was found (case insensitively) in string %s',
                 sub, str)
    end
end

function M.assertStrMatches( str, pattern, start, final )
    -- Verify a full match for the string
    -- for a partial match, simply use assertStrContains with useRe set to true
    if not strMatch( str, pattern, start, final ) then
        pattern, str = prettystrPadded(pattern, str, '\n')
        fail_fmt(2, 'Error, pattern %s was not matched by string %s',
                 pattern, str)
    end
end

function M.assertErrorMsgEquals( expectedMsg, func, ... )
    -- assert that calling f with the arguments will raise an error
    -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
    local no_error, error_msg = pcall( func, ... )
    if no_error then
        failure( 'No error generated when calling function but expected error: "'..expectedMsg..'"', 2 )
    end
    if error_msg ~= expectedMsg then
        error_msg, expectedMsg = prettystrPadded(error_msg, expectedMsg)
        fail_fmt(2, 'Exact error message expected: %s\nError message received: %s\n',
                 expectedMsg, error_msg)
    end
end

function M.assertErrorMsgContains( partialMsg, func, ... )
    -- assert that calling f with the arguments will raise an error
    -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
    local no_error, error_msg = pcall( func, ... )
    if no_error then
        failure( 'No error generated when calling function but expected error containing: '..prettystr(partialMsg), 2 )
    end
    if not string.find( error_msg, partialMsg, nil, true ) then
        error_msg, partialMsg = prettystrPadded(error_msg, partialMsg)
        fail_fmt(2, 'Error message does not contain: %s\nError message received: %s\n',
                 partialMsg, error_msg)
    end
end

function M.assertErrorMsgMatches( expectedMsg, func, ... )
    -- assert that calling f with the arguments will raise an error
    -- example: assertError( f, 1, 2 ) => f(1,2) should generate an error
    local no_error, error_msg = pcall( func, ... )
    if no_error then
        failure( 'No error generated when calling function but expected error matching: "'..expectedMsg..'"', 2 )
    end
    if not strMatch( error_msg, expectedMsg ) then
        expectedMsg, error_msg = prettystrPadded(expectedMsg, error_msg)
        fail_fmt(2, 'Error message does not match: %s\nError message received: %s\n',
                 expectedMsg, error_msg)
    end
end

--[[
Add type assertion functions to the module table M. Each of these functions
takes a single parameter "value", and checks that its Lua type matches the
expected string (derived from the function name):

M.assertIsXxx(value) -> ensure that type(value) conforms to "xxx"
]]
for _, funcName in ipairs(
    {'assertIsNumber', 'assertIsString', 'assertIsTable', 'assertIsBoolean',
     'assertIsFunction', 'assertIsUserdata', 'assertIsThread'}
) do
    local typeExpected = funcName:match("^assertIs([A-Z]%a*)$")
    -- Lua type() always returns lowercase, also make sure the match() succeeded
    typeExpected = typeExpected and typeExpected:lower()
                   or error("bad function name '"..funcName.."' for type assertion")

    M[funcName] = function(value)
        if type(value) ~= typeExpected then
            fail_fmt(2, 'Expected: a %s value, actual: type %s, value %s',
                     typeExpected, type(value), prettystrPadded(value))
        end
    end
end

--[[
Add shortcuts for verifying type of a variable, without failure (luaunit v2 compatibility)
M.isXxx(value) -> returns true if type(value) conforms to "xxx"
]]
for _, typeExpected in ipairs(
    {'Number', 'String', 'Table', 'Boolean',
     'Function', 'Userdata', 'Thread', 'Nil' }
) do
    local typeExpectedLower = typeExpected:lower()
    local isType = function(value)
        return (type(value) == typeExpectedLower)
    end
    M['is'..typeExpected] = isType
    M['is_'..typeExpectedLower] = isType
end

--[[
Add non-type assertion functions to the module table M. Each of these functions
takes a single parameter "value", and checks that its Lua type differs from the
expected string (derived from the function name):

M.assertNotIsXxx(value) -> ensure that type(value) is not "xxx"
]]
for _, funcName in ipairs(
    {'assertNotIsNumber', 'assertNotIsString', 'assertNotIsTable', 'assertNotIsBoolean',
     'assertNotIsFunction', 'assertNotIsUserdata', 'assertNotIsThread'}
) do
    local typeUnexpected = funcName:match("^assertNotIs([A-Z]%a*)$")
    -- Lua type() always returns lowercase, also make sure the match() succeeded
    typeUnexpected = typeUnexpected and typeUnexpected:lower()
                   or error("bad function name '"..funcName.."' for type assertion")

    M[funcName] = function(value)
        if type(value) == typeUnexpected then
            fail_fmt(2, 'Not expected: a %s type, actual: value %s',
                     typeUnexpected, prettystrPadded(value))
        end
    end
end

function M.assertIs(actual, expected)
    if actual ~= expected then
        if not M.ORDER_ACTUAL_EXPECTED then
            actual, expected = expected, actual
        end
        expected, actual = prettystrPadded(expected, actual, '\n', ', ')
        fail_fmt(2, 'Expected object and actual object are not the same\nExpected: %sactual: %s',
                 expected, actual)
    end
end

function M.assertNotIs(actual, expected)
    if actual == expected then
        if not M.ORDER_ACTUAL_EXPECTED then
            expected = actual
        end
        fail_fmt(2, 'Expected object and actual object are the same object: %s',
                 prettystrPadded(expected))
    end
end

function M.assertItemsEquals(actual, expected)
    -- checks that the items of table expected
    -- are contained in table actual. Warning, this function
    -- is at least O(n^2)
    if not _is_table_items_equals(actual, expected ) then
        expected, actual = prettystrPadded(expected, actual)
        fail_fmt(2, 'Contents of the tables are not identical:\nExpected: %s\nActual: %s',
                 expected, actual)
    end
end

----------------------------------------------------------------
--                     Compatibility layer
----------------------------------------------------------------

-- for compatibility with LuaUnit v2.x
function M.wrapFunctions(...)
    -- In LuaUnit version <= 2.1 , this function was necessary to include
    -- a test function inside the global test suite. Nowadays, the functions
    -- are simply run directly as part of the test discovery process.
    -- so just do nothing !
    io.stderr:write[[Use of WrapFunctions() is no longer needed.
Just prefix your test function names with "test" or "Test" and they
will be picked up and run by LuaUnit.
]]
end

local list_of_funcs = {
    -- { official function name , alias }

    -- general assertions
    { 'assertEquals'            , 'assert_equals' },
    { 'assertItemsEquals'       , 'assert_items_equals' },
    { 'assertNotEquals'         , 'assert_not_equals' },
    { 'assertAlmostEquals'      , 'assert_almost_equals' },
    { 'assertNotAlmostEquals'   , 'assert_not_almost_equals' },
    { 'assertTrue'              , 'assert_true' },
    { 'assertFalse'             , 'assert_false' },
    { 'assertStrContains'       , 'assert_str_contains' },
    { 'assertStrIContains'      , 'assert_str_icontains' },
    { 'assertNotStrContains'    , 'assert_not_str_contains' },
    { 'assertNotStrIContains'   , 'assert_not_str_icontains' },
    { 'assertStrMatches'        , 'assert_str_matches' },
    { 'assertError'             , 'assert_error' },
    { 'assertErrorMsgEquals'    , 'assert_error_msg_equals' },
    { 'assertErrorMsgContains'  , 'assert_error_msg_contains' },
    { 'assertErrorMsgMatches'   , 'assert_error_msg_matches' },
    { 'assertIs'                , 'assert_is' },
    { 'assertNotIs'             , 'assert_not_is' },
    { 'wrapFunctions'           , 'WrapFunctions' },
    { 'wrapFunctions'           , 'wrap_functions' },

    -- type assertions: assertIsXXX -> assert_is_xxx
    { 'assertIsNumber'          , 'assert_is_number' },
    { 'assertIsString'          , 'assert_is_string' },
    { 'assertIsTable'           , 'assert_is_table' },
    { 'assertIsBoolean'         , 'assert_is_boolean' },
    { 'assertIsNil'             , 'assert_is_nil' },
    { 'assertIsFunction'        , 'assert_is_function' },
    { 'assertIsThread'          , 'assert_is_thread' },
    { 'assertIsUserdata'        , 'assert_is_userdata' },

    -- type assertions: assertIsXXX -> assertXxx
    { 'assertIsNumber'          , 'assertNumber' },
    { 'assertIsString'          , 'assertString' },
    { 'assertIsTable'           , 'assertTable' },
    { 'assertIsBoolean'         , 'assertBoolean' },
    { 'assertIsNil'             , 'assertNil' },
    { 'assertIsFunction'        , 'assertFunction' },
    { 'assertIsThread'          , 'assertThread' },
    { 'assertIsUserdata'        , 'assertUserdata' },

    -- type assertions: assertIsXXX -> assert_xxx (luaunit v2 compat)
    { 'assertIsNumber'          , 'assert_number' },
    { 'assertIsString'          , 'assert_string' },
    { 'assertIsTable'           , 'assert_table' },
    { 'assertIsBoolean'         , 'assert_boolean' },
    { 'assertIsNil'             , 'assert_nil' },
    { 'assertIsFunction'        , 'assert_function' },
    { 'assertIsThread'          , 'assert_thread' },
    { 'assertIsUserdata'        , 'assert_userdata' },

    -- type assertions: assertNotIsXXX -> assert_not_is_xxx
    { 'assertNotIsNumber'       , 'assert_not_is_number' },
    { 'assertNotIsString'       , 'assert_not_is_string' },
    { 'assertNotIsTable'        , 'assert_not_is_table' },
    { 'assertNotIsBoolean'      , 'assert_not_is_boolean' },
    { 'assertNotIsNil'          , 'assert_not_is_nil' },
    { 'assertNotIsFunction'     , 'assert_not_is_function' },
    { 'assertNotIsThread'       , 'assert_not_is_thread' },
    { 'assertNotIsUserdata'     , 'assert_not_is_userdata' },

    -- type assertions: assertNotIsXXX -> assertNotXxx (luaunit v2 compat)
    { 'assertNotIsNumber'       , 'assertNotNumber' },
    { 'assertNotIsString'       , 'assertNotString' },
    { 'assertNotIsTable'        , 'assertNotTable' },
    { 'assertNotIsBoolean'      , 'assertNotBoolean' },
    { 'assertNotIsNil'          , 'assertNotNil' },
    { 'assertNotIsFunction'     , 'assertNotFunction' },
    { 'assertNotIsThread'       , 'assertNotThread' },
    { 'assertNotIsUserdata'     , 'assertNotUserdata' },

    -- type assertions: assertNotIsXXX -> assert_not_xxx
    { 'assertNotIsNumber'       , 'assert_not_number' },
    { 'assertNotIsString'       , 'assert_not_string' },
    { 'assertNotIsTable'        , 'assert_not_table' },
    { 'assertNotIsBoolean'      , 'assert_not_boolean' },
    { 'assertNotIsNil'          , 'assert_not_nil' },
    { 'assertNotIsFunction'     , 'assert_not_function' },
    { 'assertNotIsThread'       , 'assert_not_thread' },
    { 'assertNotIsUserdata'     , 'assert_not_userdata' },

    -- all assertions with Coroutine duplicate Thread assertions
    { 'assertIsThread'          , 'assertIsCoroutine' },
    { 'assertIsThread'          , 'assertCoroutine' },
    { 'assertIsThread'          , 'assert_is_coroutine' },
    { 'assertIsThread'          , 'assert_coroutine' },
    { 'assertNotIsThread'       , 'assertNotIsCoroutine' },
    { 'assertNotIsThread'       , 'assertNotCoroutine' },
    { 'assertNotIsThread'       , 'assert_not_is_coroutine' },
    { 'assertNotIsThread'       , 'assert_not_coroutine' },
}

-- Create all aliases in M
for _,v in ipairs( list_of_funcs ) do
    local funcname, alias = v[1], v[2]
    M[alias] = M[funcname]

    if EXPORT_ASSERT_TO_GLOBALS then
        _G[funcname] = M[funcname]
        _G[alias] = M[funcname]
    end
end

----------------------------------------------------------------
--
--                     Outputters
--
----------------------------------------------------------------

-- A common "base" class for outputters
-- For concepts involved (class inheritance) see http://www.lua.org/pil/16.2.html

local genericOutput = { __class__ = 'genericOutput' } -- class
local genericOutput_MT = { __index = genericOutput } -- metatable
M.genericOutput = genericOutput -- publish, so that custom classes may derive from it

function genericOutput.new(runner, default_verbosity)
    -- runner is the "parent" object controlling the output, usually a LuaUnit instance
    local t = { runner = runner }
    if runner then
        t.result = runner.result
        t.verbosity = runner.verbosity or default_verbosity
        t.fname = runner.fname
    else
        t.verbosity = default_verbosity
    end
    return setmetatable( t, genericOutput_MT)
end

-- abstract ("empty") methods
function genericOutput:startSuite() end
function genericOutput:startClass(className) end
function genericOutput:startTest(testName) end
function genericOutput:addStatus(node) end
function genericOutput:endTest(node) end
function genericOutput:endClass() end
function genericOutput:endSuite() end


----------------------------------------------------------------
--                     class TapOutput
----------------------------------------------------------------

local TapOutput = genericOutput.new() -- derived class
local TapOutput_MT = { __index = TapOutput } -- metatable
TapOutput.__class__ = 'TapOutput'

    -- For a good reference for TAP format, check: http://testanything.org/tap-specification.html

    function TapOutput.new(runner)
        local t = genericOutput.new(runner, M.VERBOSITY_LOW)
        return setmetatable( t, TapOutput_MT)
    end
    function TapOutput:startSuite()
        print("1.."..self.result.testCount)
        print('# Started on '..self.result.startDate)
    end
    function TapOutput:startClass(className)
        if className ~= '[TestFunctions]' then
            print('# Starting class: '..className)
        end
    end

    function TapOutput:addStatus( node )
        io.stdout:write("not ok ", self.result.currentTestNumber, "\t", node.testName, "\n")
        if self.verbosity > M.VERBOSITY_LOW then
           print( prefixString( '    ', node.msg ) )
        end
        if self.verbosity > M.VERBOSITY_DEFAULT then
           print( prefixString( '    ', node.stackTrace ) )
        end
    end

    function TapOutput:endTest( node )
        if node:isPassed() then
            io.stdout:write("ok     ", self.result.currentTestNumber, "\t", node.testName, "\n")
        end
    end

    function TapOutput:endSuite()
        print( '# '..M.LuaUnit.statusLine( self.result ) )
        return self.result.notPassedCount
    end


-- class TapOutput end

----------------------------------------------------------------
--                     class JUnitOutput
----------------------------------------------------------------

-- See directory junitxml for more information about the junit format
local JUnitOutput = genericOutput.new() -- derived class
local JUnitOutput_MT = { __index = JUnitOutput } -- metatable
JUnitOutput.__class__ = 'JUnitOutput'

    function JUnitOutput.new(runner)
        local t = genericOutput.new(runner, M.VERBOSITY_LOW)
        t.testList = {}
        return setmetatable( t, JUnitOutput_MT )
    end

    function JUnitOutput:startSuite()
        -- open xml file early to deal with errors
        if self.fname == nil then
            error('With Junit, an output filename must be supplied with --name!')
        end
        if string.sub(self.fname,-4) ~= '.xml' then
            self.fname = self.fname..'.xml'
        end
        self.fd = io.open(self.fname, "w")
        if self.fd == nil then
            error("Could not open file for writing: "..self.fname)
        end

        print('# XML output to '..self.fname)
        print('# Started on '..self.result.startDate)
    end
    function JUnitOutput:startClass(className)
        if className ~= '[TestFunctions]' then
            print('# Starting class: '..className)
        end
    end
    function JUnitOutput:startTest(testName)
        print('# Starting test: '..testName)
    end

    function JUnitOutput:addStatus( node )
        if node:isFailure() then
            print('# Failure: ' .. node.msg)
            -- print('# ' .. node.stackTrace)
        elseif node:isError() then
            print('# Error: ' .. node.msg)
            -- print('# ' .. node.stackTrace)
        end
    end

    function JUnitOutput:endSuite()
        print( '# '..M.LuaUnit.statusLine(self.result))

        -- XML file writing
        self.fd:write('<?xml version="1.0" encoding="UTF-8" ?>\n')
        self.fd:write('<testsuites>\n')
        self.fd:write(string.format(
            '    <testsuite name="LuaUnit" id="00001" package="" hostname="localhost" tests="%d" timestamp="%s" time="%0.3f" errors="%d" failures="%d">\n',
            self.result.runCount, self.result.startIsodate, self.result.duration, self.result.errorCount, self.result.failureCount ))
        self.fd:write("        <properties>\n")
        self.fd:write(string.format('            <property name="Lua Version" value="%s"/>\n', _VERSION ) )
        self.fd:write(string.format('            <property name="LuaUnit Version" value="%s"/>\n', M.VERSION) )
        -- XXX please include system name and version if possible
        self.fd:write("        </properties>\n")

        for i,node in ipairs(self.result.tests) do
            self.fd:write(string.format('        <testcase classname="%s" name="%s" time="%0.3f">\n',
                node.className, node.testName, node.duration ) )
            if node:isNotPassed() then
                self.fd:write(node:statusXML())
            end
            self.fd:write('        </testcase>\n')
        end

        -- Next two lines are needed to validate junit ANT xsd, but really not useful in general:
        self.fd:write('    <system-out/>\n')
        self.fd:write('    <system-err/>\n')

        self.fd:write('    </testsuite>\n')
        self.fd:write('</testsuites>\n')
        self.fd:close()
        return self.result.notPassedCount
    end


-- class TapOutput end

----------------------------------------------------------------
--                     class TextOutput
----------------------------------------------------------------

--[[

-- Python Non verbose:

For each test: . or F or E

If some failed tests:
    ==============
    ERROR / FAILURE: TestName (testfile.testclass)
    ---------
    Stack trace


then --------------
then "Ran x tests in 0.000s"
then OK or FAILED (failures=1, error=1)

-- Python Verbose:
testname (filename.classname) ... ok
testname (filename.classname) ... FAIL
testname (filename.classname) ... ERROR

then --------------
then "Ran x tests in 0.000s"
then OK or FAILED (failures=1, error=1)

-- Ruby:
Started
 .
 Finished in 0.002695 seconds.
 
 1 tests, 2 assertions, 0 failures, 0 errors

-- Ruby:
>> ruby tc_simple_number2.rb
Loaded suite tc_simple_number2
Started
F..
Finished in 0.038617 seconds.
 
  1) Failure:
test_failure(TestSimpleNumber) [tc_simple_number2.rb:16]:
Adding doesn't work.
<3> expected but was
<4>.
 
3 tests, 4 assertions, 1 failures, 0 errors

-- Java Junit
.......F.
Time: 0,003
There was 1 failure:
1) testCapacity(junit.samples.VectorTest)junit.framework.AssertionFailedError
    at junit.samples.VectorTest.testCapacity(VectorTest.java:87)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)

FAILURES!!!
Tests run: 8,  Failures: 1,  Errors: 0


-- Maven

# mvn test
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running math.AdditionTest
Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 
0.03 sec <<< FAILURE!

Results :

Failed tests: 
  testLireSymbole(math.AdditionTest)

Tests run: 2, Failures: 1, Errors: 0, Skipped: 0


-- LuaUnit 
---- non verbose
* display . or F or E when running tests
---- verbose
* display test name + ok/fail
----
* blank line
* number) ERROR or FAILURE: TestName
   Stack trace
* blank line
* number) ERROR or FAILURE: TestName
   Stack trace

then --------------
then "Ran x tests in 0.000s (%d not selected, %d skipped)"
then OK or FAILED (failures=1, error=1)


]]

local TextOutput = genericOutput.new() -- derived class
local TextOutput_MT = { __index = TextOutput } -- metatable
TextOutput.__class__ = 'TextOutput'

    function TextOutput.new(runner)
        local t = genericOutput.new(runner, M.VERBOSITY_DEFAULT)
        t.errorList = {}
        return setmetatable( t, TextOutput_MT )
    end

    function TextOutput:startSuite()
        if self.verbosity > M.VERBOSITY_DEFAULT then
            print( 'Started on '.. self.result.startDate )
        end
    end

    function TextOutput:startTest(testName)
        if self.verbosity > M.VERBOSITY_DEFAULT then
            io.stdout:write( "    ", self.result.currentNode.testName, " ... " )
        end
    end

    function TextOutput:endTest( node )
        if node:isPassed() then
            if self.verbosity > M.VERBOSITY_DEFAULT then
                io.stdout:write("Ok\n")
            else
                io.stdout:write(".")
            end
        else
            if self.verbosity > M.VERBOSITY_DEFAULT then
                print( node.status )
                print( node.msg )
                --[[
                -- find out when to do this:
                if self.verbosity > M.VERBOSITY_DEFAULT then
                    print( node.stackTrace )
                end
                ]]
            else
                -- write only the first character of status
                io.stdout:write(string.sub(node.status, 1, 1))
            end
        end
    end

    function TextOutput:displayOneFailedTest( index, failure )
        print(index..") "..failure.testName )
        print( failure.msg )
        print( failure.stackTrace )
        print()
    end

    function TextOutput:displayFailedTests()
        if self.result.notPassedCount == 0 then return end
        print("Failed tests:")
        print("-------------")
        for i,v in ipairs(self.result.notPassed) do
            self:displayOneFailedTest( i, v )
        end
    end

    function TextOutput:endSuite()
        if self.verbosity > M.VERBOSITY_DEFAULT then
            print("=========================================================")
        else
            print()
        end
        self:displayFailedTests()
        print( M.LuaUnit.statusLine( self.result ) )
        local ignoredString = ""
        if self.result.notPassedCount == 0 then
            print('OK')
        end
    end

-- class TextOutput end


----------------------------------------------------------------
--                     class NilOutput
----------------------------------------------------------------

local function nopCallable()
    --print(42)
    return nopCallable
end

local NilOutput = { __class__ = 'NilOuptut' } -- class
local NilOutput_MT = { __index = nopCallable } -- metatable

function NilOutput.new(runner)
    return setmetatable( { __class__ = 'NilOutput' }, NilOutput_MT )
end

----------------------------------------------------------------
--
--                     class LuaUnit
--
----------------------------------------------------------------

M.LuaUnit = {
    outputType = TextOutput,
    verbosity = M.VERBOSITY_DEFAULT,
    __class__ = 'LuaUnit'
}
local LuaUnit_MT = { __index = M.LuaUnit }

if EXPORT_ASSERT_TO_GLOBALS then
    LuaUnit = M.LuaUnit
end

    function M.LuaUnit.new()
        return setmetatable( {}, LuaUnit_MT )
    end

    -----------------[[ Utility methods ]]---------------------

    function M.LuaUnit.asFunction(aObject)
        -- return "aObject" if it is a function, and nil otherwise
        if 'function' == type(aObject) then return aObject end
    end

    function M.LuaUnit.isClassMethod(aName)
        -- return true if aName contains a class + a method name in the form class:method
        return string.find(aName, '.', nil, true) ~= nil
    end

    function M.LuaUnit.splitClassMethod(someName)
        -- return a pair className, methodName for a name in the form class:method
        -- return nil if not a class + method name
        -- name is class + method
        local hasMethod, methodName, className
        hasMethod = string.find(someName, '.', nil, true )
        if not hasMethod then return nil end
        methodName = string.sub(someName, hasMethod+1)
        className = string.sub(someName,1,hasMethod-1)
        return className, methodName
    end

    function M.LuaUnit.isMethodTestName( s )
        -- return true is the name matches the name of a test method
        -- default rule is that is starts with 'Test' or with 'test'
        return string.sub(s, 1, 4):lower() == 'test'
    end

    function M.LuaUnit.isTestName( s )
        -- return true is the name matches the name of a test
        -- default rule is that is starts with 'Test' or with 'test'
        return string.sub(s, 1, 4):lower() == 'test'
    end

    function M.LuaUnit.collectTests()
        -- return a list of all test names in the global namespace
        -- that match LuaUnit.isTestName

        local testNames = {}
        for k, v in pairs(_G) do
            if M.LuaUnit.isTestName( k ) then
                table.insert( testNames , k )
            end
        end
        table.sort( testNames )
        return testNames
    end

    function M.LuaUnit.parseCmdLine( cmdLine )
        -- parse the command line
        -- Supported command line parameters:
        -- --verbose, -v: increase verbosity
        -- --quiet, -q: silence output
        -- --error, -e: treat errors as fatal (quit program)
        -- --output, -o, + name: select output type
        -- --pattern, -p, + pattern: run test matching pattern, may be repeated
        -- --name, -n, + fname: name of output file for junit, default to stdout
        -- [testnames, ...]: run selected test names
        --
        -- Returns a table with the following fields:
        -- verbosity: nil, M.VERBOSITY_DEFAULT, M.VERBOSITY_QUIET, M.VERBOSITY_VERBOSE
        -- output: nil, 'tap', 'junit', 'text', 'nil'
        -- testNames: nil or a list of test names to run
        -- pattern: nil or a list of patterns

        local result = {}
        local state = nil
        local SET_OUTPUT = 1
        local SET_PATTERN = 2
        local SET_FNAME = 3

        if cmdLine == nil then
            return result
        end

        local function parseOption( option )
            if option == '--help' or option == '-h' then
                result['help'] = true
                return
            elseif option == '--version' then
                result['version'] = true
                return
            elseif option == '--verbose' or option == '-v' then
                result['verbosity'] = M.VERBOSITY_VERBOSE
                return
            elseif option == '--quiet' or option == '-q' then
                result['verbosity'] = M.VERBOSITY_QUIET
                return
            elseif option == '--error' or option == '-e' then
                result['quitOnError'] = true
                return
            elseif option == '--failure' or option == '-f' then
                result['quitOnFailure'] = true
                return
            elseif option == '--output' or option == '-o' then
                state = SET_OUTPUT
                return state
            elseif option == '--name' or option == '-n' then
                state = SET_FNAME
                return state
            elseif option == '--pattern' or option == '-p' then
                state = SET_PATTERN
                return state
            end
            error('Unknown option: '..option,3)
        end

        local function setArg( cmdArg, state )
            if state == SET_OUTPUT then
                result['output'] = cmdArg
                return
            elseif state == SET_FNAME then
                result['fname'] = cmdArg
                return
            elseif state == SET_PATTERN then
                if result['pattern'] then
                    table.insert( result['pattern'], cmdArg )
                else
                    result['pattern'] = { cmdArg }
                end
                return
            end
            error('Unknown parse state: '.. state)
        end


        for i, cmdArg in ipairs(cmdLine) do
            if state ~= nil then
                setArg( cmdArg, state, result )
                state = nil
            else
                if cmdArg:sub(1,1) == '-' then
                    state = parseOption( cmdArg )
                else
                    if result['testNames'] then
                        table.insert( result['testNames'], cmdArg )
                    else
                        result['testNames'] = { cmdArg }
                    end
                end
            end
        end

        if result['help'] then
            M.LuaUnit.help()
        end

        if result['version'] then
            M.LuaUnit.version()
        end

        if state ~= nil then
            error('Missing argument after '..cmdLine[ #cmdLine ],2 )
        end

        return result
    end

    function M.LuaUnit.help()
        print(M.USAGE)
        os.exit(0)
    end

    function M.LuaUnit.version()
        print('LuaUnit v'..M.VERSION..' by Philippe Fremy <phil@freehackers.org>')
        os.exit(0)
    end

    function M.LuaUnit.patternInclude( patternFilter, expr )
        -- check if any of patternFilter is contained in expr. If so, return true.
        -- return false if None of the patterns are contained in expr
        -- if patternFilter is nil, return true (no filtering)
        if patternFilter == nil then
            return true
        end

        for i,pattern in ipairs(patternFilter) do
            if string.find(expr, pattern) then
                return true
            end
        end

        return false
    end

----------------------------------------------------------------
--                     class NodeStatus
----------------------------------------------------------------

    local NodeStatus = { __class__ = 'NodeStatus' } -- class
    local NodeStatus_MT = { __index = NodeStatus } -- metatable
    M.NodeStatus = NodeStatus

    -- values of status
    NodeStatus.PASS  = 'PASS'
    NodeStatus.FAIL  = 'FAIL'
    NodeStatus.ERROR = 'ERROR'

    function NodeStatus.new( number, testName, className )
        local t = { number = number, testName = testName, className = className }
        setmetatable( t, NodeStatus_MT )
        t:pass()
        return t
    end

    function NodeStatus:pass()
        self.status = self.PASS
        -- useless but we know it's the field we want to use
        self.msg = nil
        self.stackTrace = nil
    end

    function NodeStatus:fail(msg, stackTrace)
        self.status = self.FAIL
        self.msg = msg
        self.stackTrace = stackTrace
    end

    function NodeStatus:error(msg, stackTrace)
        self.status = self.ERROR
        self.msg = msg
        self.stackTrace = stackTrace
    end

    function NodeStatus:isPassed()
        return self.status == NodeStatus.PASS
    end

    function NodeStatus:isNotPassed()
        -- print('hasFailure: '..prettystr(self))
        return self.status ~= NodeStatus.PASS
    end

    function NodeStatus:isFailure()
        return self.status == NodeStatus.FAIL
    end

    function NodeStatus:isError()
        return self.status == NodeStatus.ERROR
    end

    function NodeStatus:statusXML()
        if self:isError() then
            return table.concat(
                {'            <error type="', xmlEscape(self.msg), '">\n',
                 '                <![CDATA[', xmlCDataEscape(self.stackTrace),
                 ']]></error>\n'})
        elseif self:isFailure() then
            return table.concat(
                {'            <failure type="', xmlEscape(self.msg), '">\n',
                 '                <![CDATA[', xmlCDataEscape(self.stackTrace),
                 ']]></failure>\n'})
        end
        return '            <passed/>\n' -- (not XSD-compliant! normally shouldn't get here)
    end

    --------------[[ Output methods ]]-------------------------

    local function conditional_plural(number, singular)
        -- returns a grammatically well-formed string "%d <singular/plural>"
        local suffix = ''
        if number ~= 1 then -- use plural
            suffix = (singular:sub(-2) == 'ss') and 'es' or 's'
        end
        return string.format('%d %s%s', number, singular, suffix)
    end

    function M.LuaUnit.statusLine(result)
        -- return status line string according to results
        local s = {
            string.format('Ran %d tests in %0.3f seconds',
                          result.runCount, result.duration),
            conditional_plural(result.passedCount, 'success'),
        }
        if result.notPassedCount > 0 then
            if result.failureCount > 0 then
                table.insert(s, conditional_plural(result.failureCount, 'failure'))
            end
            if result.errorCount > 0 then
                table.insert(s, conditional_plural(result.errorCount, 'error'))
            end
        else
            table.insert(s, '0 failures')
        end
        if result.nonSelectedCount > 0 then
            table.insert(s, string.format("%d non-selected", result.nonSelectedCount))
        end
        return table.concat(s, ', ')
    end

    function M.LuaUnit:startSuite(testCount, nonSelectedCount)
        self.result = {
            testCount = testCount,
            nonSelectedCount = nonSelectedCount,
            passedCount = 0,
            runCount = 0,
            currentTestNumber = 0,
            currentClassName = "",
            currentNode = nil,
            suiteStarted = true,
            startTime = os.clock(),
            startDate = os.date(os.getenv('LUAUNIT_DATEFMT')),
            startIsodate = os.date('%Y-%m-%dT%H:%M:%S'),
            patternFilter = self.patternFilter,
            tests = {},
            failures = {},
            errors = {},
            notPassed = {},
        }

        self.outputType = self.outputType or TextOutput
        self.output = self.outputType.new(self)
        self.output:startSuite()
    end

    function M.LuaUnit:startClass( className )
        self.result.currentClassName = className
        self.output:startClass( className )
    end

    function M.LuaUnit:startTest( testName  )
        self.result.currentTestNumber = self.result.currentTestNumber + 1
        self.result.runCount = self.result.runCount + 1
        self.result.currentNode = NodeStatus.new(
            self.result.currentTestNumber,
            testName,
            self.result.currentClassName
        )
        self.result.currentNode.startTime = os.clock()
        table.insert( self.result.tests, self.result.currentNode )
        self.output:startTest( testName )
    end

    function M.LuaUnit:addStatus( err )
        -- "err" is expected to be a table / result from protectedCall()
        if err.status == NodeStatus.PASS then return end

        local node = self.result.currentNode

        --[[ As a first approach, we will report only one error or one failure for one test.

        However, we can have the case where the test is in failure, and the teardown is in error.
        In such case, it's a good idea to report both a failure and an error in the test suite. This is
        what Python unittest does for example. However, it mixes up counts so need to be handled carefully: for
        example, there could be more (failures + errors) count that tests. What happens to the current node ?

        We will do this more intelligent version later.
        ]]

        -- if the node is already in failure/error, just don't report the new error (see above)
        if node.status ~= NodeStatus.PASS then return end

        if err.status == NodeStatus.FAIL then
            node:fail( err.msg, err.trace )
            table.insert( self.result.failures, node )
        elseif err.status == NodeStatus.ERROR then
            node:error( err.msg, err.trace )
            table.insert( self.result.errors, node )
        end

        if node:isFailure() or node:isError() then
            -- add to the list of failed tests (gets printed separately)
            table.insert( self.result.notPassed, node )
        end
        self.output:addStatus( node )
    end

    function M.LuaUnit:endTest()
        local node = self.result.currentNode
        -- print( 'endTest() '..prettystr(node))
        -- print( 'endTest() '..prettystr(node:isNotPassed()))
        node.duration = os.clock() - node.startTime
        node.startTime = nil
        self.output:endTest( node )

        if node:isPassed() then
            self.result.passedCount = self.result.passedCount + 1
        elseif node:isError() then
            if self.quitOnError or self.quitOnFailure then
                -- Runtime error - abort test execution as requested by
                -- "--error" option. This is done by setting a special
                -- flag that gets handled in runSuiteByInstances().
                print("\nERROR during LuaUnit test execution:\n" .. node.msg)
                self.result.aborted = true
            end
        elseif node:isFailure() then
            if self.quitOnFailure then
                -- Failure - abort test execution as requested by
                -- "--failure" option. This is done by setting a special
                -- flag that gets handled in runSuiteByInstances().
                print("\nFailure during LuaUnit test execution:\n" .. node.msg)
                self.result.aborted = true
            end
        end
        self.result.currentNode = nil
    end

    function M.LuaUnit:endClass()
        self.output:endClass()
    end

    function M.LuaUnit:endSuite()
        if self.result.suiteStarted == false then
            error('LuaUnit:endSuite() -- suite was already ended' )
        end
        self.result.duration = os.clock()-self.result.startTime
        self.result.suiteStarted = false

        -- Expose test counts for outputter's endSuite(). This could be managed
        -- internally instead, but unit tests (and existing use cases) might
        -- rely on these fields being present.
        self.result.notPassedCount = #self.result.notPassed
        self.result.failureCount = #self.result.failures
        self.result.errorCount = #self.result.errors

        self.output:endSuite()
    end

    function M.LuaUnit:setOutputType(outputType)
        -- default to text
        -- tap produces results according to TAP format
        if outputType:upper() == "NIL" then
            self.outputType = NilOutput
            return
        end
        if outputType:upper() == "TAP" then
            self.outputType = TapOutput
            return
        end
        if outputType:upper() == "JUNIT" then
            self.outputType = JUnitOutput
            return
        end
        if outputType:upper() == "TEXT" then
            self.outputType = TextOutput
            return
        end
        error( 'No such format: '..outputType,2)
    end

    --------------[[ Runner ]]-----------------

    function M.LuaUnit:protectedCall(classInstance, methodInstance, prettyFuncName)
        -- if classInstance is nil, this is just a function call
        -- else, it's method of a class being called.

        local function err_handler(e)
            -- transform error into a table, adding the traceback information
            return {
                status = NodeStatus.ERROR,
                msg = e,
                trace = string.sub(debug.traceback("", 3), 2)
            }
        end

        local ok, err
        if classInstance then
            -- stupid Lua < 5.2 does not allow xpcall with arguments so let's use a workaround
            ok, err = xpcall( function () methodInstance(classInstance) end, err_handler )
        else
            ok, err = xpcall( function () methodInstance() end, err_handler )
        end
        if ok then
            return {status = NodeStatus.PASS}
        end

        -- determine if the error was a failed test:
        -- We do this by stripping the failure prefix from the error message,
        -- while keeping track of the gsub() count. A non-zero value -> failure
        local failed
        err.msg, failed = err.msg:gsub(M.FAILURE_PREFIX, "", 1)
        if failed > 0 then
            err.status = NodeStatus.FAIL
        end

        -- reformat / improve the stack trace
        if prettyFuncName then -- we do have the real method name
            err.trace = err.trace:gsub("in (%a+) 'methodInstance'", "in %1 '"..prettyFuncName.."'")
        end
        if STRIP_LUAUNIT_FROM_STACKTRACE then
            err.trace = stripLuaunitTrace(err.trace)
        end

        return err -- return the error "object" (table)
    end


    function M.LuaUnit:execOneFunction(className, methodName, classInstance, methodInstance)
        -- When executing a test function, className and classInstance must be nil
        -- When executing a class method, all parameters must be set

        if type(methodInstance) ~= 'function' then
            error( tostring(methodName)..' must be a function, not '..type(methodInstance))
        end

        local prettyFuncName
        if className == nil then
            className = '[TestFunctions]'
            prettyFuncName = methodName
        else
            prettyFuncName = className..'.'..methodName
        end

        if self.lastClassName ~= className then
            if self.lastClassName ~= nil then
                self:endClass()
            end
            self:startClass( className )
            self.lastClassName = className
        end

        self:startTest(prettyFuncName)

        -- run setUp first (if any)
        if classInstance then
            local func = self.asFunction( classInstance.setUp )
                         or self.asFunction( classInstance.Setup )
                         or self.asFunction( classInstance.setup )
                         or self.asFunction( classInstance.SetUp )
            if func then
                self:addStatus(self:protectedCall(classInstance, func, className..'.setUp'))
            end
        end

        -- run testMethod()
        if self.result.currentNode:isPassed() then
            self:addStatus(self:protectedCall(classInstance, methodInstance, prettyFuncName))
        end

        -- lastly, run tearDown (if any)
        if classInstance then
            local func = self.asFunction( classInstance.tearDown )
                         or self.asFunction( classInstance.TearDown )
                         or self.asFunction( classInstance.teardown )
                         or self.asFunction( classInstance.Teardown )
            if func then
                self:addStatus(self:protectedCall(classInstance, func, className..'.tearDown'))
            end
        end

        self:endTest()
    end

    function M.LuaUnit.expandOneClass( result, className, classInstance )
        -- add all test methods of classInstance to result
        for methodName, methodInstance in sortedPairs(classInstance) do
            if M.LuaUnit.asFunction(methodInstance) and M.LuaUnit.isMethodTestName( methodName ) then
                table.insert( result, { className..'.'..methodName, classInstance } )
            end
        end
    end

    function M.LuaUnit.expandClasses( listOfNameAndInst )
        -- expand all classes (provided as {className, classInstance}) to a list of {className.methodName, classInstance}
        -- functions and methods remain untouched
        local result = {}

        for i,v in ipairs( listOfNameAndInst ) do
            local name, instance = v[1], v[2]
            if M.LuaUnit.asFunction(instance) then
                table.insert( result, { name, instance } )
            else
                if type(instance) ~= 'table' then
                    error( 'Instance must be a table or a function, not a '..type(instance)..', value '..prettystr(instance))
                end
                if M.LuaUnit.isClassMethod( name ) then
                    local className, methodName = M.LuaUnit.splitClassMethod( name )
                    local methodInstance = instance[methodName]
                    if methodInstance == nil then
                        error( "Could not find method in class "..tostring(className).." for method "..tostring(methodName) )
                    end
                    table.insert( result, { name, instance } )
                else
                    M.LuaUnit.expandOneClass( result, name, instance )
                end
            end
        end

        return result
    end

    function M.LuaUnit.applyPatternFilter( patternFilter, listOfNameAndInst )
        local included, excluded = {}, {}
        for i, v in ipairs( listOfNameAndInst ) do
            -- local name, instance = v[1], v[2]
            if M.LuaUnit.patternInclude( patternFilter, v[1] ) then
                table.insert( included, v )
            else
                table.insert( excluded, v )
            end
        end
        return included, excluded
    end

    function M.LuaUnit:runSuiteByInstances( listOfNameAndInst )
        -- Run an explicit list of tests. All test instances and names must be supplied.
        -- each test must be one of:
        --   * { function name, function instance }
        --   * { class name, class instance }
        --   * { class.method name, class instance }

        local expandedList = self.expandClasses( listOfNameAndInst )
        local filteredList, filteredOutList
            = self.applyPatternFilter( self.patternFilter, expandedList )

        self:startSuite( #filteredList, #filteredOutList )

        for i,v in ipairs( filteredList ) do
            local name, instance = v[1], v[2]
            if M.LuaUnit.asFunction(instance) then
                self:execOneFunction( nil, name, nil, instance )
            else
                if type(instance) ~= 'table' then
                    error( 'Instance must be a table or a function, not a '..type(instance)..', value '..prettystr(instance))
                else
                    assert( M.LuaUnit.isClassMethod( name ) )
                    local className, methodName = M.LuaUnit.splitClassMethod( name )
                    local methodInstance = instance[methodName]
                    if methodInstance == nil then
                        error( "Could not find method in class "..tostring(className).." for method "..tostring(methodName) )
                    end
                    self:execOneFunction( className, methodName, instance, methodInstance )
                end
            end
            if self.result.aborted then break end -- "--error" or "--failure" option triggered
        end

        if self.lastClassName ~= nil then
            self:endClass()
        end

        self:endSuite()

        if self.result.aborted then
            print("LuaUnit ABORTED (as requested by --error or --failure option)")
            os.exit(-2)
        end
    end

    function M.LuaUnit:runSuiteByNames( listOfName )
        -- Run an explicit list of test names

        local instanceName, instance
        local listOfNameAndInst = {}

        for i,name in ipairs( listOfName ) do
            if M.LuaUnit.isClassMethod( name ) then
                local className, methodName = M.LuaUnit.splitClassMethod( name )
                instanceName = className
                instance = _G[instanceName]

                if instance == nil then
                    error( "No such name in global space: "..instanceName )
                end

                if type(instance) ~= 'table' then
                    error( 'Instance of '..instanceName..' must be a table, not '..type(instance))
                end

                local methodInstance = instance[methodName]
                if methodInstance == nil then
                    error( "Could not find method in class "..tostring(className).." for method "..tostring(methodName) )
                end

            else
                -- for functions and classes
                instanceName = name
                instance = _G[instanceName]
            end

            if instance == nil then
                error( "No such name in global space: "..instanceName )
            end

            if (type(instance) ~= 'table' and type(instance) ~= 'function') then
                error( 'Name must match a function or a table: '..instanceName )
            end

            table.insert( listOfNameAndInst, { name, instance } )
        end

        self:runSuiteByInstances( listOfNameAndInst )
    end

    function M.LuaUnit.run(...)
        -- Run some specific test classes.
        -- If no arguments are passed, run the class names specified on the
        -- command line. If no class name is specified on the command line
        -- run all classes whose name starts with 'Test'
        --
        -- If arguments are passed, they must be strings of the class names
        -- that you want to run or generic command line arguments (-o, -p, -v, ...)

        local runner = M.LuaUnit.new()
        return runner:runSuite(...)
    end

    function M.LuaUnit:runSuite( ... )

        local args = {...}
        if type(args[1]) == 'table' and args[1].__class__ == 'LuaUnit' then
            -- run was called with the syntax M.LuaUnit:runSuite()
            -- we support both M.LuaUnit.run() and M.LuaUnit:run()
            -- strip out the first argument
            table.remove(args,1)
        end

        if #args == 0 then
            args = cmdline_argv
        end

        local no_error, val = pcall( M.LuaUnit.parseCmdLine, args )
        if not no_error then
            print(val) -- error message
            print()
            print(M.USAGE)
            os.exit(-1)
        end

        local options = val

        -- We expect these option fields to be either `nil` or contain
        -- valid values, so it's safe to always copy them directly.
        self.verbosity     = options.verbosity
        self.quitOnError   = options.quitOnError
        self.quitOnFailure = options.quitOnFailure
        self.fname         = options.fname
        self.patternFilter = options.pattern

        if options.output and options.output:lower() == 'junit' and options.fname == nil then
            print('With junit output, a filename must be supplied with -n or --name')
            os.exit(-1)
        end

        if options.output then
            no_error, val = pcall(self.setOutputType, self, options.output)
            if not no_error then
                print(val) -- error message
                print()
                print(M.USAGE)
                os.exit(-1)
            end
        end

        self:runSuiteByNames( options.testNames or M.LuaUnit.collectTests() )

        return self.result.notPassedCount
    end
-- class LuaUnit

-- For compatbility with LuaUnit v2
M.run = M.LuaUnit.run
M.Run = M.LuaUnit.run

function M:setVerbosity( verbosity )
    M.LuaUnit.verbosity = verbosity
end
M.set_verbosity = M.setVerbosity
M.SetVerbosity = M.setVerbosity


return M
local luaunit = require('test.luaunit')
local parser = require('brickscript.parser')


function testTetris() doTest('tetris') end
function testCars() doTest('cars') end


function doTest(name)
  local test = require ('test.parser.complex.'..name)
  local parsed = parser:match(test[1])
  luaunit.assertEquals(parsed, test[2])
end

os.exit( luaunit.LuaUnit.run() )
local luaunit = require('test.luaunit')
local parser = require('brickscript.parser')

function testCall() doTest('call') end
function testList() doTest('list') end
function testAssign() doTest('assign') end
function testUpdate() doTest('update') end
function testComment() doTest('comment') end


function doTest(name)
  local test = require ('test.parser.simple.'..name)
  local parsed = parser:match(test[1])
  luaunit.assertEquals(parsed, test[2])
end

os.exit( luaunit.LuaUnit.run() )
local luaunit = require('test.luaunit')
local parser = require('brickscript.parser')
local Runtime = require('brickscript.runtime')

function testAssign() doTest('assign') end
function testUpdate() doTest('update') end
function testBind() doTest('bind') end
function testList() doTest('list') end
function testCall() doTest('call') end
function testBitmap() doTest('bitmap') end
function testComment() doTest('comment') end
function testNumber() doTest('number') end


function doTest(name)
  local tests = require ('test.runtime.'..name)
  print('\n\n\nRT Test:', name)
  for i, test in pairs(tests) do
    print('\nSubtest: ', i)
    local runtime = Runtime()
    if test.configure then test.configure(runtime) end
    local code = test[1]
    print('code:\n'..code)
    local tree = parser:match(code)
    print('parsed: ', luaunit.prettystr(tree))
    local result = runtime.run(tree)
    print('result: ', result)
    luaunit.assertEquals(result, test[2])
  end
end
-- FIXME tests and runtime logging

os.exit( luaunit.LuaUnit.run() )
return {[[

car:
-#-
###
-#-
#-#
pos: [3, 16]

 // FIXME block args:   time|
  displayMain.draw(car, pos, -) // FIXME display.main.draw()
  <{pos << pos.<}
  >{pos << pos.>}
  col: collision(displayMain, car, pos)
  col.onTrue{ gameover }
  time.every(2){ displayMain.v }
  score.inc
  displayMain.draw(car, pos, #)


]],
{
    {
        "assign",
        {"name", "car"},
        {"bitmap", {{0, 1, 0}, {1, 1, 1}, {0, 1, 0}, {1, 0, 1}}}
    },
    {"assign", {"name", "pos"}, {"list", {{"num", "3"}, {"num", "16"}}}},
    {
        "call",
        {"name", "displayMain"},
        "draw",
        {{"call", {}, "car", {}}, {"call", {}, "pos", {}}, {"bitmap", {{0}}}}
    },
    {
        "call",
        {},
        "<",
        {{"block", {"update", {"name", "pos"}, {"call", {"name", "pos"}, "<", {}}}}}
    },
    {
        "call",
        {},
        ">",
        {{"block", {"update", {"name", "pos"}, {"call", {"name", "pos"}, ">", {}}}}}
    },
    {
        "assign",
        {"name", "col"},
        {
            "call",
            {},
            "collision",
            {
                {"call", {}, "displayMain", {}},
                {"call", {}, "car", {}},
                {"call", {}, "pos", {}}
            }
        }
    },
    {"call", {"name", "col"}, "onTrue", {{"block", {"call", {}, "gameover", {}}}}},
    {
        "call",
        {"name", "time"},
        "every",
        {{"num", "2"}, {"block", {"call", {"name", "displayMain"}, "v", {}}}}
    },
    {"call", {"name", "score"}, "inc", {}},
    {
        "call",
        {"name", "displayMain"},
        "draw",
        {{"call", {}, "car", {}}, {"call", {}, "pos", {}}, {"bitmap", {{1}}}}
    }
}



}
return {[[

bricks: [
##
##,
####
,
-#
##
#-
]

brickPos: [3,0]
brick: bricks(1)
lastBrickMoved: -

{
  displayNext.clear
  displayNext.draw(next, [0,0])
  displayMain.draw(brick, brickPos, -)

  brickPos << brickPos.v

  // input
  <{brickPos << brickPos.<}
  >{brickPos << brickPos.>}
  v{}
  o{brick << brick.rotate}

  col: collision(displayMain, brick, brickPos)
  col.onTrue{ tr }
  col.onFalse{fa}
  displayMain.draw(brick, brickPos, #)
  gameover
  newBrick
  lastBrickMoved << -

  // TODO fun().moreFun()
}

]],
{
    {
        "assign",
        {"name", "bricks"},
        {
            "list",
            {
                {"bitmap", {{1, 1}, {1, 1}}},
                {"bitmap", {{1, 1, 1, 1}}},
                {"bitmap", {{0, 1}, {1, 1}, {1, 0}}}
            }
        }
    },
    {"assign", {"name", "brickPos"}, {"list", {{"num", "3"}, {"num", "0"}}}},
    {"assign", {"name", "brick"}, {"call", {}, "bricks", {{"num", "1"}}}},
    {"assign", {"name", "lastBrickMoved"}, {"bitmap", {{0}}}},
    {
        "block",
        {"call", {"name", "displayNext"}, "clear", {}},
        {
            "call",
            {"name", "displayNext"},
            "draw",
            {{"call", {}, "next", {}}, {"list", {{"num", "0"}, {"num", "0"}}}}
        },
        {
            "call",
            {"name", "displayMain"},
            "draw",
            {{"call", {}, "brick", {}}, {"call", {}, "brickPos", {}}, {"bitmap", {{0}}}}
        },
        {"update", {"name", "brickPos"}, {"call", {"name", "brickPos"}, "v", {}}},
        {
            "call",
            {},
            "<",
            {
                {
                    "block",
                    {"update", {"name", "brickPos"}, {"call", {"name", "brickPos"}, "<", {}}}
                }
            }
        },
        {
            "call",
            {},
            ">",
            {
                {
                    "block",
                    {"update", {"name", "brickPos"}, {"call", {"name", "brickPos"}, ">", {}}}
                }
            }
        },
        {"call", {}, "v", {{"block"}}},
        {
            "call",
            {},
            "o",
            {
                {
                    "block",
                    {"update", {"name", "brick"}, {"call", {"name", "brick"}, "rotate", {}}}
                }
            }
        },
        {
            "assign",
            {"name", "col"},
            {
                "call",
                {},
                "collision",
                {
                    {"call", {}, "displayMain", {}},
                    {"call", {}, "brick", {}},
                    {"call", {}, "brickPos", {}}
                }
            }
        },
        {"call", {"name", "col"}, "onTrue", {{"block", {"call", {}, "tr", {}}}}},
        {"call", {"name", "col"}, "onFalse", {{"block", {"call", {}, "fa", {}}}}},
        {
            "call",
            {"name", "displayMain"},
            "draw",
            {{"call", {}, "brick", {}}, {"call", {}, "brickPos", {}}, {"bitmap", {{1}}}}
        },
        {"call", {}, "gameover", {}},
        {"call", {}, "newBrick", {}},
        {"update", {"name", "lastBrickMoved"}, {"bitmap", {{0}}}}
    }
}



}
return {[[
score:0
score:
  9
game.speed : 19
a.b.c: 2
fun : {}
pos: [2,9]
bitmap:
###
#-#
###

bricks: [
###
###,
#
]

bricks: [
-#
##
#-
,
---
]


hiscore : game.score

]],
{
    {"assign", {"var", "score"}, {"get", {"num", "0"}}},
    {"assign", {"var", "score"}, {"get", {"num", "9"}}},
    {"assign", {"var", {"call", "game", {}}, "speed"}, {"get", {"num", "19"}}},
    {
        "assign",
        {"var", {"call", "a", {}}, {"call", "b", {}}, "c"},
        {"get", {"num", "2"}}
    },
    {"assign", {"var", "fun"}, {"get", {"block", {},{}}}},
    {
        "assign",
        {"var", "pos"},
        {"get", {"list", {{"get", {"num", "2"}}, {"get", {"num", "9"}}}}}
    },
    {
        "assign",
        {"var", "bitmap"},
        {"get", {"bitmap", {{1, 1, 1}, {1, 0, 1}, {1, 1, 1}}}}
    },
    {
        "assign",
        {"var", "bricks"},
        {
            "get",
            {
                "list",
                {{"get", {"bitmap", {{1, 1, 1}, {1, 1, 1}}}}, {"get", {"bitmap", {{1}}}}}
            }
        }
    },
    {
        "assign",
        {"var", "bricks"},
        {
            "get",
            {
                "list",
                {
                    {"get", {"bitmap", {{0, 1}, {1, 1}, {1, 0}}}},
                    {"get", {"bitmap", {{0, 0, 0}}}}
                }
            }
        }
    },
    {
        "assign",
        {"var", "hiscore"},
        {"get", {"call", "game", {}}, {"call", "score", {}}}
    }
}


}
return {[[
#
2
a
a.x
a.pos.x()
2.next()
2.next

{a.inc}.while{isSmall}

println
println()
println(1, 5)
print(
,line,
line
,line,
)
do{ something }
repeat(3){ something }
repeat(3)  { something }

###
###
.shift(1,2)
getTable.getValue()
game.over()

2.plus(3)
5.times{i ->
  print(i)
}

getFile().withWriter{writer -> writer.write(1)}

list.sort{a,b -> a.awesomeness.minus(b.awesomeness)}

[1,3,4].sum()


]],

{
    {"get", {"bitmap", {{1}}}},
    {"get", {"num", "2"}},
    {"get", {"call", "a", {}}},
    {"get", {"call", "a", {}}, {"call", "x", {}}},
    {"get", {"call", "a", {}}, {"call", "pos", {}}, {"call", "x", {}}},
    {"get", {"num", "2"}, {"call", "next", {}}},
    {"get", {"num", "2"}, {"call", "next", {}}},
    {
        "get",
        {"block", {},  {{"get", {"call", "a", {}}, {"call", "inc", {}}}}},
        {"call", "while", {{"block", {}, {{"get", {"call", "isSmall", {}}}}}}}
    },
    {"get", {"call", "println", {}}},
    {"get", {"call", "println", {}}},
    {"get", {"call", "println", {{"get", {"num", "1"}}, {"get", {"num", "5"}}}}},
    {
        "get",
        {
            "call",
            "print",
            {
                {"get", {"call", "line", {}}},
                {"get", {"call", "line", {}}},
                {"get", {"call", "line", {}}}
            }
        }
    },
    {"get", {"call", "do", {{"block", {}, {{"get", {"call", "something", {}}}}}}}},
    {
        "get",
        {
            "call",
            "repeat",
            {{"get", {"num", "3"}}, {"block", {}, {{"get", {"call", "something", {}}}}}}
        }
    },
    {
        "get",
        {
            "call",
            "repeat",
            {{"get", {"num", "3"}}, {"block", {}, {{"get", {"call", "something", {}}}}}}
        }
    },
    {
        "get",
        {"bitmap", {{1, 1, 1}, {1, 1, 1}}},
        {"call", "shift", {{"get", {"num", "1"}}, {"get", {"num", "2"}}}}
    },
    {"get", {"call", "getTable", {}}, {"call", "getValue", {}}},
    {"get", {"call", "game", {}}, {"call", "over", {}}},
    {"get", {"num", "2"}, {"call", "plus", {{"get", {"num", "3"}}}}},
    {
        "get",
        {"num", "5"},
        {
            "call",
            "times",
            {
                {
                    "block",
                    {"i"},
                    {{"get", {"call", "print", {{"get", {"call", "i", {}}}}}}}
                }
            }
        }
    },
    {
        "get",
        {"call", "getFile", {}},
        {
            "call",
            "withWriter",
            {
                {
                    "block",
                    {"writer"},
                    {{"get", {"call", "writer", {}}, {"call", "write", {{"get", {"num", "1"}}}}}}
                }
            }
        }
    },
    {
        "get",
        {"call", "list", {}},
        {
            "call",
            "sort",
            {
                {
                    "block",
                    {"a", "b"},
                    {{
                        "get",
                        {"call", "a", {}},
                        {"call", "awesomeness", {}},
                        {"call", "minus", {{"get", {"call", "b", {}}, {"call", "awesomeness", {}}}}}
                    }}
                }
            }
        }
    },
    {
        "get",
        {"list", {{"get", {"num", "1"}}, {"get", {"num", "3"}}, {"get", {"num", "4"}}}},
        {"call", "sum", {}}
    }
}


}
return {[[
1
// oneline
// another line
1 /* block */ 1/* multiple
lines
*/1
TODO get life
2 FIXME should be 3
3 XXX do not commit
1
TODO
1 FIXME
//
/**/
/*
*/
]],
{
    {"get", {"num", "1"}},
    {"get", {"num", "1"}},
    {"get", {"num", "1"}},
    {"get", {"num", "1"}},
    {"task", "todo", "get life"},
    {"get", {"num", "2"}},
    {"task", "fixme", "should be 3"},
    {"get", {"num", "3"}},
    {"task", "xxx", "do not commit"},
    {"get", {"num", "1"}},
    {"task", "todo", ""},
    {"get", {"num", "1"}},
    {"task", "fixme", ""}

}

}
return {[[
[2,9]
[2]

[#,
##
--, 3]

[{block}, fn, fn(something){withparams}]

[
1,
2
,
3
,4
]

[,1,]
[2]
[]

]],
{
    {"get", {"list", {{"get", {"num", "2"}}, {"get", {"num", "9"}}}}},
    {"get", {"list", {{"get", {"num", "2"}}}}},
    {
        "get",
        {
            "list",
            {
                {"get", {"bitmap", {{1}}}},
                {"get", {"bitmap", {{1, 1}, {0, 0}}}},
                {"get", {"num", "3"}}
            }
        }
    },
    {
        "get",
        {
            "list",
            {
                {"get", {"block", {}, {{"get", {"call", "block", {}}}}}},
                {"get", {"call", "fn", {}}},
                {
                    "get",
                    {
                        "call",
                        "fn",
                        {
                            {"get", {"call", "something", {}}},
                            {"block", {}, {{"get", {"call", "withparams", {}}}}}
                        }
                    }
                }
            }
        }
    },
    {
        "get",
        {
            "list",
            {
                {"get", {"num", "1"}},
                {"get", {"num", "2"}},
                {"get", {"num", "3"}},
                {"get", {"num", "4"}}
            }
        }
    },
    {"get", {"list", {{"get", {"num", "1"}}}}},
    {"get", {"list", {{"get", {"num", "2"}}}}},
    {"get", {"list", {}}}
}

}
return {[[
score:0
score << 2
score << score.plus(1)

game.speed:2
game.speed << maxSpeed

]],
{
    {"assign", {"var", "score"}, {"get", {"num", "0"}}},
    {"update", {"var", "score"}, {"get", {"num", "2"}}},
    {
        "update",
        {"var", "score"},
        {"get", {"call", "score", {}}, {"call", "plus", {{"get", {"num", "1"}}}}}
    },
    {"assign", {"var", {"call", "game", {}}, "speed"}, {"get", {"num", "2"}}},
    {
        "update",
        {"var", {"call", "game", {}}, "speed"},
        {"get", {"call", "maxSpeed", {}}}
    }
}


}
return {
{[[
  15
]]
, 15 },

{[[
  a:5
  a
]]
, 5 },

{[[
  a:12
  b:10
  c:a
  c
]]
, 12 },


{[[
  a:[]
  a.b: 2
  a.b
]]
, 2 },


{[[
  player: []
  player.head: []
  player.head.width: 9
  player.head.color: 1
  player.head.width
]]
, 9 },


}
return {

{
configure=function(runtime)
  runtime.assign('amount', 999)
end,
[[
  amount
]]
,
999
},

{
configure=function(runtime)
  runtime.assign('amount', 10)
end,
[[
  fromOutside: amount
  fromOutside
]]
,
10
},

{
configure=function(runtime)
  runtime.assign('getTheBestNumber', function() return 25 end)
end,
[[
  getTheBestNumber
]]
,
25
},

{
configure=function(runtime)
  runtime.assign('getTheBestNumber', function() return 25 end)
end,
[[
  getTheBestNumber()
]]
,
25
},

{
configure=function(runtime)
  runtime.assign('getTheBestNumber', function() return 25 end)
end,
[[
  getTheBestNumber: 17
  getTheBestNumber()
]]
,
17
},


}
return {

{[[
###.w
]]
, 3 },


{[[
b:
###
##
#
b.w

]]
, 3 },

{[[

##
#
.h

]]
, 2 },



}
local add = function(a, b) return a+b end
local rept = function(n, fn) print('repeat n times: ', n, fn); local last;for i=1, n do last=fn(i) end return last end
local prnt = function(...) print("---PRINT from script", unpack(arg)) end

local conf = function(runtime)
  runtime.assign('add', add)
  runtime.assign('repeat', rept)
  runtime.assign('print', prnt)
end

return {

{
configure=conf,
[[
  one:1
  four: add(one, 3)
  four
]]
,
4
},


{
configure=conf,
[[
  vector: [2,3]
  vector.x
]]
,
2
},


{
configure=conf,
[[
  count : {l -> l.size}
  count([2,3,3])
]]
,
3
},



{
configure=conf,
[[
  count : {l ->
    nothing
    l.size
  }
  count([2,3,3])
]]
,
3
},


{
configure=conf,
[[
  2.plus(3)
]]
,
5
},


{
configure=conf,
[[
  2.plus(3).plus(1)
]]
,
6
},


{
configure=conf,
[[
  a:1
  a.plus(3)
]]
,
4
},

{
configure=conf,
[[
  a:1
  2.plus(a)
]]
,
3
},

{
configure=conf,

[[
  a:0
  repeat(3, {i ->
    a << i
  })
  a
]]
,
3
},

{
configure=conf,

[[
  a:1
  repeat(2, {i ->
    a:5
    a << i
  })
]]
,
2
},


{
configure=conf,

[[
  a:1
  repeat(2, {i ->
    a:5
    a << i
  })
  a
]]
,
1
},


{
configure=conf,

[[
  a:0
  repeat(3, {i ->
    a << a.plus(i)
  })
  a
]]
,
6
},

{
configure=conf,

[[
m:[]
fun: { machine ->
  machine.gameover << 1
}
fun(m)
m.gameover
]]
,
1
},


{
configure=conf,

[[
  a:0
  repeat(3, {i ->
    a << a.plus(i)
  })
  a
]]
,
6
},


{
configure=conf,

[[
  add: {a,b -> a.plus(b)}
  add(3, 2)
]]
,
5
},

{
configure=conf,
[[
  plusTwo: {n -> n.plus(2)}
  plusFour: {n -> plusTwo(n.plus(2)) }
  plusFour(6)
]]
,
10
},

{
configure=conf,
[[
  val : 1
  set10: {val << 10}
  set10
  val
]]
,
10
},

{
configure=conf,
[[
  val : 1
  set: {n -> val << n}
  set(4)
  val
]]
,
4
},

{
configure=conf,
[[
  nop0: {}
  nop1: {i -> }
  nop2: {i,j -> }
  nop0
  nop0()
  nop0(1)
  nop1()
  nop1(1)
  nop1(1,2)
  nop2()
  nop2(1)
  nop2(1,2)
  nop2(1,2,3)
]]
,
nil
},



}
local output = ''

return {

{configure=function(runtime)
  runtime.assign('task', {
    todo = function(msg) output = output .. "TODO"..msg end,
    fixme = function(msg) output = output .. "FIXME".. msg end,
    xxx = function(msg) output = output .. "XXX".. msg end,
  })
  runtime.assign('getOut', function() return output end)
end,

[[
1
// oneline
// another line
1 /* block */ 1/* multiple
lines
*/1
TODO get life
2 FIXME should be 3
3 XXX do not commit
3.times{
  TODO
}
getOut()
]]
, "TODOget lifeFIXMEshould be 3XXXdo not commitTODOTODOTODO" }, -- but we do not have strings in brickscript :(



}
return {

{
[[
  l:[1,2,3]
  l(1)
]]
,
 2
},


{
[[
  list:[1,2,3]
  list(4)
]]
,
 nil -- TODO?
},


{
[[
  [].size
]]
,
 0
},


{
[[
  list: [1,2,[11,22,33, [44], 55], ]
  nested: list(2)
  nn: nested(3) //TODO nested(3)(0)
  nn(0)
]]
,
 44
},


{
[[
  list: [1,2]
  list.x
]]
,
 1
},

{
[[
  list: [1,2,8]
  list.size
]]
,
 3
},


{
[[
  a: 3
  b: 5
  list: [1,a, b]
  list(2)
]]
,
 5
},


{
[[
  tail: [2, [] ]
  list: [1, tail]
  t: list(1)
  t(1).isEmpty
]]
,
 true
},


{
configure = function (runtime) math.randomseed(7) end,
[[
  list: [1, 2, 3]
  [list.random, list.random, list.random, list.random, list.random]
]]
,
{2, 3, 2, 1, 1}
},


{[[ [1,20].> ]], {2,20}},
{[[ [1,20].< ]], {0,20}},
{[[ [1,20].^ ]], {1,19}},
{[[ [1,20].v ]], {1,21}},
{[[ [1,20].>.> ]], {3,20}},



}
return {

{[[ 1.<(2){333} ]], 333},
{[[ 1.<(1){333} ]], nil},

{[[ 3.>(2){333} ]], 333},
{[[ 1.>(2){333} ]], nil},

{[[ 1.<=(2){333} ]], 333},
{[[ 1.<=(0){333} ]], nil},

{[[ 1.>=(1){333} ]], 333},
{[[ 1.>=(3){333} ]], nil},

{[[ 1.=(1){333} ]], 333},
{[[ 1.=(2){333} ]], nil},


{[[ 1.plus(2) ]], 3},
{[[ 3.minus(2) ]], 1},

{[[
n: 0
3.times{n << n.plus(1)}
n
]], 3},


{[[
n: 0
6.times{i -> n << i.plus(n)}
n
]], 15},

{[[
n: 0
6.times{i -> n << n.plus(i)}
n
]], 15},

}
return {

{[[
score:0
score << 2
score
]]
, 2 },


{[[
v:2
v << [1,2,3]
v.size
]]
, 3 },


}
Copyright (c) 2014, Cedric Knight <fonts@cedders.com>,
with Reserved Font Name "Segment7".

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.
OTTO  €  `BASE 	   &¬   CFF ¹›Ó  ì  ºFFTMk¥ðD  &¼   GDEF±¢  %¨   JGPOS®ï½Ô  &,   ~GSUBDØLæ  %ô   8OS/2XÔb,  P   `cmap1W5,  „  Fheadc@O   ì   6hheaS _  $   $hmtxÒh  &Ø  maxpP   H   nameŠÇ]  °  Òpost     Ì          åV—T_<õ è    Ï¸~‰    Ï¸~‰  ÿ8Ñ              ÿ8 ZI  þxÑ d                P    IX  Š»  ŒŠ»ÿçß 1   	                     PfEd    ÿ ÿ8 Z  È       ÂÂ         ®        ±d       (       C       #”       Ê       	ç         	  b    	    	  1  	  FL  	  ¸  	  Ó  	   ñ S t r i c t l y   s e v e n - s e g m e n t   ( p l u s   p o i n t )   c a l c u l a t o r   d i s p l a y   f a c e ,   f i x e d - w i d t h   a n d   f r e e .     ( c )   C e d r i c   K n i g h t   2 0 1 4 .     L i c e n s e d   u n d e r   S I L   O p e n   F o n t   L i c e n c e   v 1 . 1 .     R e s e r v e d   n a m e :   S e g m e n t 7 .  Strictly seven-segment (plus point) calculator display face, fixed-width and free.  (c) Cedric Knight 2014.  Licensed under SIL Open Font Licence v1.1.  Reserved name: Segment7.  S e g m e n t 7  Segment7  S t a n d a r d  Standard  F o n t F o r g e   2 . 0   :   S e g m e n t 7   :   7 - 6 - 2 0 1 4  FontForge 2.0 : Segment7 : 7-6-2014  S e g m e n t 7  Segment7  V e r s i o n      Version    S e g m e n t 7 S t a n d a r d  Segment7Standard                  <                ÿÿÿ    ÿÿ       
              	 
                        ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~  € Å Æ È Ê Ò × Ý â á ã å ä æ è ê é ë ì î í ï ð ò ô ó õ ÷ ö û ú ü ý   ± £ ¤ ¨   · à ¯ ª   µ ©   Ç Ù   ²     ¦ ¶           « »   ç ù À ¢ ­         ¬ ¼   ¡ Á Ä Ö                 ø                    ¸       Ã Ë Â Ì É Î Ï Ð Í Ô Õ   Ó Û Ü Ú       °       ¹           ÿý                           Segment7Standard   7øb øcødøeøfŒˆ‹‹‹û\úeù´¯  ° 1È L      $ + 2 9 @ G N U \ c j q x  †  ” › ¢ © ° · ¾ Å Ì Ó Ú á è ï ö ý '.5<CJQX_fmt{‚‰—ž¥¬³ºÁÈÏÖÝäëòò£«³»uni0000uni0001uni0002uni0003uni0004uni0005uni0006uni0007uni0008uni0009uni000Auni000Buni000Cuni000Duni000Euni000Funi0010uni0011uni0012uni0013uni0014uni0015uni0016uni0017uni0018uni0019uni001Auni001Buni001Cuni001Duni001Euni001Funi007Funi0080uni0081uni0082uni0083uni0084uni0085uni0086uni0087uni0088uni0089uni008Auni008Buni008Cuni008Duni008Euni008Funi0090uni0091uni0092uni0093uni0094uni0095uni0096uni0097uni0098uni0099uni009Auni009Buni009Cuni009Duni009Euni009Funi00A0uni00ADuni00B2uni00B3uni00B5uni00B9Strictly seven-segment (plus point) calculator display face, fixed-width and free.  (c) Cedric Knight 2014.  Licensed under SIL Open Font Licence v1.1.  Reserved name: Segment7.Segment7Segment7Standard   ‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ ¡¢£¤¥¦        h 	 
                        ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ | B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈ ` a b g d   f ƒ ª ‹ j —É ¥ € ¡ œÊË }Ì s r …Í  x ž › £ { ® « ¬ ° ­ ¯ Š ± µ ² ³ ´ ¹ ¶ · ¸ š º ¾ » ¼ ¿ ½ ¨  Ä Á Â Ã Å  • Ë È É Í Ê Ì  Î Ò Ï Ð Ñ Ö Ó Ô Õ § × Û Ø Ù Ü Ú Ÿ “ á Þ ß à â ¢ ã  " 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V v  ¶ í&H^‘Êò4@NwÆç$g–à<aÁ:Nb€²ÿA‡ºþ:k°í	Bz¡¹ñ	@	|	²	Ë

B
„
Æ6xªÝ 7\h{È"f­Þ)Zi¢Ú8XÉ^“ÁU’Öÿ OPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~€¯°±²³êëìíîïðñòóôõö÷øùúûüýþÿ 	
a®¯°±²³´µüýþÿ 	
‹½øE½½½ø½½øyø©üy½üwøEøüEû\ú|‹úeû\úeú|þevï÷å ÷ÅŸø;özêpø¡ùŽ 
ˆ±ý?!
øIv÷ÁwŸwÌwÐÝùa"
÷ùð#
‰é÷›êi ÷ÅŸ€÷ç$
Àûx÷ú%
°÷÷Ì 
‰éS ÷û ÷Œê8Ÿ ÷ç`&
 '
(ûÒù"
0~÷(
dü)
`*
‰éhvø%v÷¡êLwŸw ÷ç`&
 '
(ûÒù"
0~÷(
dü)
`*
¯ ÷¾êi ÷ÅŸÀ÷@øV%
ÑM+
°›ø0 
øIv÷îwŸwø;öÐø¡ùŽ 
‰év÷ãwÊv÷¡êLw°÷ç$
û×÷Â,
p-
4Fø"
8~÷(
‰éhvø%v÷¡êywŸw ÷ç`&
 '
0û‰ùD(
dü)
`*
(›ø0 
‰é÷›ê~v÷îwŸw€÷ç$
Àûx÷ú%
°÷÷Ì 
Äv÷Óê~v÷îwŸwÀ÷@øV%
ÑM+
°›ø0 
‰éhv€÷ç@&
€'
Ö÷¼)
@*
÷÷ê÷@øV%
vïø•êøÇÚ!
Ûv÷¼êSwÊv÷îw¨Øø.
È ÷ %
÷÷Ì/
˜0
‰éhv·v÷ãwÊv÷¡êLwÌw˜÷çX&
˜'
û×÷Â,
8-
Fø"
~÷(
dü)
X*
›ø0 
Ävø%v÷îwŸwø*÷Èøoø+
è›ø0 
‰év÷¼êSwÊv÷¡êyw€÷ç$
Pû×÷Â.
øJ(
 ûêûÙ%

÷÷Ì 
‰éhv÷Óê~v÷¡êywŸw€÷ç@&
€'
û‰ùD(
 ûêûÙ%
ÑM)
@*
›ø0 
Äv÷Óê~v÷ÁwŸwÌw´Ýùa"
Äûg%
ÑM+
›ø0/
¤0
‰éhv÷Ôé~v÷¡æPwŸw@øpøR\~ûxÍ=œ¥ž÷µ ûåî1
û÷ÝI`2
üCP3
€müÎ4
‰éhv¶v÷¾égv·v÷¡æPw€÷ç4
ûÒù3
~÷	I`2
ûêûÚ1
ÓNR\~ûx@5
(üDµ‡†‡{ûÅç¾—÷}Ävø%v÷¡êywŸwà÷/ù (
dü+
Ð›ø0 
‰éhv·v÷¼êSwÊv÷¡êLwÌw€ ÷ç@ &
€ '
( û×÷Â.
 Fø"
 ~÷(
 ûêûÙ%
ÑM)
@ *
€›ø0 
‰éhv÷Óê~v÷¡êLwŸwÌw€÷ç@&
€'
ûÒù"
~÷(
 ûêûÙ%
ÑM)
@*
›ø0 
÷÷ê÷@øV%
vï÷å ÷ÅŸø;özêpø¡ùŽ 
ˆ±ý?!
÷ç$
û×÷Â.
 ÷ %
‰é÷›ê÷ç$
ûx÷ú%
‰éS €÷ç@&
€'
Ö÷¼)
@*
Ûv÷¼êSwÊv÷¡êyw Øø.
ˆøJ(
ÀûêûÙ%
”÷÷Ì 
‰éS  ÷§ê?Ÿ¡ ÷ŒêeŸ€÷ç@&
€'
(û×÷Â.
øJ(
ûêûÙ%
ÑM)
@*
›ø0 
Äv·v÷¼êSwÊv÷¡êLwÌwÐØø.
ÊFø"
Ä~÷(
àûêûÙ%
ÑM+
É›ø0 
‰éS  ÷§ê?Ÿ¡ ÷˜Ÿ‚÷çB&
‚'
*û×÷Â.
Fø{û©6
ûg%
ÑM)
B*
‰éj ÷ºŸ¡ ÷Œê8Ÿ°÷ç$
û×÷Â,
p-
4Fø"
8~÷(
‰éS  ÷§ê?Ÿ¡ ÷ÅŸ‚÷çB&
‚'
*û×÷Â.
 ÷ %
ÑM)
B*
›ø0/
0
‰év÷¼êSwÊv÷¡êLw€÷ç$
Pû×÷Â.

Fø"
~÷(
 ûêûÙ%
Æ ÷§ê?Ÿ¡ ÷Œê8Ÿ Øø.
”Fø"
ˆ~÷(
ÀûêûÙ%
‰éhv·v÷ãwÊv÷¡êLw˜÷çX&
˜'
û×÷Â,
8-
Fø"
~÷(
dü)
X*
¯  ÷§ê?Ÿ¡ ÷˜Ÿ¤ŸÖØø.
Fø{û©Î6
æûg%
ÑM+
›ø0/
Î0
¯ ÷û ÷ÅŸø*÷øoø+
›ø0 
‰éS  ÷ºŸ¡ ÷ÅŸœ÷ç\&
œ'
û×÷Â,
<-
÷Ø¹)
\*
›ø0#
¯  ÷§ê?Ÿ¡ ÷Œê8ŸÐØø.
ÊFø"
Ä~÷(
àûêûÙ%
ÑM+
‰éj ÷ºŸ¡ ÷˜Ÿ¸÷ç$
û×÷Â,
x-
Fø"
Øø.
 ÷ %
ÑM+
›ø0#
Äv·v÷ãwÊv÷¡êLwÌwðØø.
ôFø"
ø~÷(
dü+
ò›ø0 
‰éS  ÷ºŸ¡ ÷Œê8Ÿ¤Ÿ˜÷çX&
˜'
û×÷Â,
8-
Fø"
~÷(
dü)
X*
›ø0 
Æ ÷§ê?Ÿ¡ ÷Œê8Ÿ¤Ÿ Øø.
”Fø"
ˆ~÷(
ÀûêûÙ%
’÷÷Ì 
¯ ÷¾êi ÷Œê8Ÿ¤Ÿ¨Ýùa"
~÷(
ÀûêûÙ%
ÑM+
¤›ø0 
Æ ÷§ê?Ÿ Øø.
À ÷ %
‰éS ÷¿éi ÷Œæ<Ÿ€÷ç4
ûÒù3
~÷	I`2
 ûêûÚ1
ÓNR\~ûx@5
‰éj ÷§ê?Ÿ¡ ÷˜Ÿ„÷ç$
Tû×÷Â.
Fø{û©6
$ûg%
‰éS  ÷ºŸ¡ ÷˜Ÿ¤Ÿž÷ç^&
ž'
û×÷Â,
>-
Fø"
÷Çû¥)
^*
›ø0#
‰éS  ÷ºŸ¡ ÷˜Ÿ¤Ÿž÷ç^&
ž'
û×÷Â,
>-
Fø"
÷Çû¥)
^*
›ø0#
‰éS  ÷§ê?Ÿ¡ ÷˜Ÿ¤Ÿƒ÷çC&
ƒ'
+û×÷Â.
Fø{û©6
ûg%
ÑM)
C*
›ø0/
0
‰é÷›ê÷ê÷ç$
û‰ùD(
ûêûÙ%
‰éS ÷¾êi ÷˜Ÿ¤Ÿ„÷çD&
„'
ûÒù"
$ûg%
ÑM)
D*
›ø0/
0
Æ ÷§ê?Ÿ¡ ÷ŒêeŸ Øø.
ˆøJ(
ÀûêûÙ%
”÷÷Ì 
‰éj ÷ºŸ¡ ÷Œê8Ÿ°÷ç$
û×÷Â,
p-
4Fø"
8~÷(
Äv÷Óê~v÷ÁwŸw°Ýùa"
Àûg%
ÑM+
‰éS ÷û ÷ŒêeŸ ÷ç`&
 '
0û‰ùD(
dü)
`*
(›ø0 
øIv÷¡êLwŸwÌw Ýùa"
À~÷(
ˆ–~ 
÷÷ê÷@øV%
ø4 ÷ÅŸø;öø¡ùŽ 
‰éhv·v÷¼êSwÊv÷¡êyw€÷ç@&
€'
(û×÷Â.
øJ(
ûêûÙ%
ÑM)
@*
›ø0 
‰éhv·v÷¼êSwÊv÷Áw‚÷çB&
‚'
*û×÷Â.
Fø{û©6
ûg%
ÑM)
B*
÷ç$
û×÷Â.
 ÷ %
‰éhv·v÷¼êSwÊv÷îw‚÷çB&
‚'
*û×÷Â.
 ÷ %
ÑM)
B*
›ø0/
0
‰év÷¼êSwÊv÷¡êLwÌw€÷ç$
Pû×÷Â.

Fø"
~÷(
 ûêûÙ%
	÷÷Ì 
Ûv÷¼êSwÊv÷¡êLw Øø.
”Fø"
ˆ~÷(
ÀûêûÙ%
‰éS ÷¾êi ÷Œê8Ÿ¤Ÿ€÷ç@&
€'
ûÒù"
~÷(
 ûêûÙ%
ÑM)
@*
›ø0 
Äv·v÷¼êSwÊv÷ÁwÔØø.
Fø{û©Ì6
äûg%
ÑM+
Ävø*òøoø+
‰éhv·v÷ãwÊv÷îwœ÷ç\&
œ'
û×÷Â,
<-
÷Ø¹)
\*
›ø0#
Äv·v÷¼êSwÊv÷¡êLwÐØø.
ÊFø"
Ä~÷(
àûêûÙ%
ÑM+
‰év÷ãwÊv÷Áw¸÷ç$
û×÷Â,
x-
Fø"
Ûv÷¼êSwÊv÷ÁwÌw¬Øø.
Fø{û©œ6
Ìûg%
÷÷Ì/
œ0
Äv·v÷¼êSwÐØø.
à ÷ %
ÑM+
‰éhv·v÷¼êSw€÷ç@&
€'
(û×÷Â.
 ÷ %
ÑM)
@*
Ûv÷¼êSwÊv÷¡êLwÌw Øø.
”Fø"
ˆ~÷(
ÀûêûÙ%
’÷÷Ì 
Äv÷Óê~v÷¡êLwŸwÌw¨Ýùa"
~÷(
ÀûêûÙ%
ÑM+
¢›ø0 
Ûv÷¼êSw Øø.
À ÷ %
‰éhv÷Ôé~v÷¡æPwŸw€÷ç4
ûÒù3
~÷	I`2
 ûêûÚ1
ÓNR\~ûx@5
‰év÷¼êSwÊv÷Áw„÷ç$
Tû×÷Â.
Fø{û©6
$ûg%
‰éhv·v÷ãw÷çP&
'
û×÷Â,
0-
÷Ø¹)
P*
‰éhv·v÷ãwÊv÷ÁwÌwž÷ç^&
ž'
û×÷Â,
>-
Fø"
÷Çû¥)
^*
›ø0#
‰éhv·v÷¼êSwÊv÷ÁwÌwƒ÷çC&
ƒ'
+û×÷Â.
Fø{û©6
ûg%
ÑM)
C*
›ø0/
0
Äv·v÷¼êSwÊv÷ÁwÌwÖØø.
Fø{û©Î6
æûg%
ÑM+
›ø0/
Î0
‰éhv÷Óê~v÷ÁwŸwÌw‚÷çB&
‚'
ûÒù"
"ûg%
ÑM)
B*
›ø0/
0
Æ ÷§ê?Ÿ¡ ÷ÅŸ¨Øø.
È ÷ %
÷÷Ì/
˜0
¯ ÷û ÷ÅŸø*÷øoø+
›ø0 
‰év÷ãwÊv÷¡êyw°÷ç$
û×÷Â,
p-
8øJ(
4–~ 
÷÷êi ÷Œê8Ÿ¤Ÿ€÷@øV%
Pû×÷Ÿ"
`~÷(
H–~ 
Æ ÷§ê?Ÿ¡ ÷˜Ÿ¤Ÿ¬Øø.
Fø{û©œ6
Ìûg%
÷÷Ì/
œ0
‰éS  ÷§ê?Ÿ¡ ÷ŒêeŸ€÷ç@&
€'
(û×÷Â.
øJ(
ûêûÙ%
ÑM)
@*
›ø0 
‰éS  ÷§ê?Ÿ¡ ÷ŒêeŸ€÷ç@&
€'
(û×÷Â.
øJ(
ûêûÙ%
ÑM)
@*
›ø0 
‰éj ÷§ê?Ÿ¡ ÷Œê8Ÿ¤Ÿ€÷ç$
Pû×÷Â.

Fø"
~÷(
 ûêûÙ%
	÷÷Ì 
øÝ‹‰±ù=¸œŒ
/	‹
ê
ŸŒÑŽŒúúeê“œùé 1    , 8 P ~ ‘ ž Á Ì Ó Ü ê ò ü':CO}†11ûjÃa®°î‘êî‹ˆ‘‰ouvmo v¤§  ©§w r{û©–sÚº—÷Z11ûjÃa®°î‘êî‹ˆ‘‰/S‹Š‹†ˆŽˆ’‚’ƒ’‚Ò‹÷"‹÷@‹’ŽŽ‹‰ˆŽv¥t©v¥;_ z£| x÷Œ‹Ë·J¾/S‹Š‹†ˆŽˆ’‚’ƒ’‚Ò‹÷"‹÷@‹’ŽŽ‹‰ˆŽv¥t©v¥H^ÛY÷“‹æåR]ûwÍ<¥ž÷´R]ûwÍ<¥ž÷´ˆƒ€ˆ{ûÄç½—÷}ˆƒ€ˆ{ûÄç½—÷}11ûjÃa®°î‘êî‹ˆ‘‰<_¡z¡|¡y÷Œ‹Ë¶I¾ÛX÷’‹åæ|û¨•rÛº–÷[/T‹‰‹†ˆŽ‡’ƒ’‚’ƒÓ‹÷!‹÷@‹’Ž‹‰ˆŽv¦s§v¦Í=œ¥ž÷µ–sÚº—÷Z                      1 :  @ @  B B  F F  O O  Y Y  b s  u z       
   DFLT      ÿÿ                 G K    
  , DFLT      ÿÿ    kern                     ý¶   /  $    
            /ý¶   1 :                        Ì=¢Ï    Ï¯ÏS    Ï¸~!I  I                                                                  § B / / / \§ / / / \ / \ / /– / / B . . X / / \§ / / / / / / / / / / / / /– / / / / / / / B / . / / / / / / / / B / B \§ / / / / / / / /– / / / / / / / B / . / / / / / / /  –   /                                                                                                   B         /                                                                                     / /               /                                              <HTML>
<HEAD>
<TITLE>Digital Graphic Labs - Redirect</TITLE>
<meta http-equiv="refresh" content="1;url=http://www.digitalgraphiclabs.com">
<script language="javascript">
<!-- 
location.replace("http://www.digitalgraphiclabs.com");
-->
</script>
</HEAD>

<BODY BGCOLOR="#460000" TEXT="#FFFFFF" LINK="#FF2020" ALINK="#FFFFFF" VLINK="#FF2020">
<CENTER>
<TABLE WIDTH="400" HEIGHT="100%" BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR><TD WIDTH="100%" HEIGHT="20" ALIGN="CENTER" VALIGN="LEFT" BGCOLOR="#FFFFFF"><FONT FACE="Arial, Sans Serif, Verdana" SIZE=3 COLOR="#000000"><B>Redirect</B></FONT></TD></TR>
<TR><TD WIDTH="100%" HEIGHT="300" ALIGN="CENTER" VALIGN="LEFT" BGCOLOR="#000000"><BR><BR><BR>
<FONT FACE="Arial, Sans Serif, Verdana" SIZE=3 COLOR="#FFFFFF">If this page does not automatically redirect you, click below to go to the Digital Graphic Labs homepage</FONT>
<BR><BR>
<FONT FACE="Arial, Sans Serif, Verdana" SIZE=3 COLOR="#FFFFFF"><A HREF="http://www.digitalgraphiclabs.com" TARGET="_top">http://www.digitalgraphiclabs.com</A>
</TD></TR>
</TD></TR>
</TABLE>
</CENTER>
</BODY>
</HTML>THIS SOFTWARE IS BEING DISTRIBUTED AS FREEWARE. IT MAY BE 
FREELY USED, COPIED AND DISTRIBUTED, AS LONG AS IT IS NOT SOLD, 
AND ALL ORIGINAL FILES ARE INCLUDED, INCLUDING THIS LICENSE. 
THE USER IS NOT PERMITTED TO CHARGE FOR DISTRIBUTING THIS SOFTWARE 
(EITHER FOR PROFIT OR MERELY TO RECOVER MEDIA AND DISTRIBUTION
COSTS) WHETHER AS A STAND-ALONE PRODUCT, OR AS PART OF A
COMPILATION OR ANTHOLOGY, WITHOUT EXPLICIT PRIOR WRITTEN PERMISSION
OF THE CREATOR.  BY USING THIS SOFTWARE, THE USER AGREES TO
THESE TERMS AND THE TERMS OF THE DISCLAIMER BELOW:

DISCLAIMER:
BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO 
WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY 
APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING, THE 
COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE SOFTWARE "AS 
IS," WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE 
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE 
RESTS WITH THE USER. SHOULD THE SOFTWARE PROVE DEFECTIVE, THE USER
ASSUMES THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

IN NO EVENT, UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN 
WRITING, WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY 
MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED ABOVE, BE 
LIABLE TO THE USER FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
PUNITIVE, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES
SUSTAINED BY THE USER OR THIRD PARTIES OR A FAILURE OF THE
SOFTWARE TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER
OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.    
 €   OS/2Ãü—   ¬   Ncmap,®œ   ü  ¦glyf¿'T  ¤  {VheadÚñ“¾  ü   6hheam  €4   $hmtxóXQ  €X  ÔlocaeŽŠ]  ‚,   ìmaxp {‘  ƒ    nameH$‚  ƒ8  ±post     „ì                                                     @  ðÿ   à                                              BSCDEFNGXHQKYPU89:;<=>?@AJTOLMR_	
VIWZ[o !"#$%&'()*+,-./01234567\`]^         t                       c    aj kbnp                             g     iheflm          d                                Œ   "     ÿSax’ÆÜ    " & 0 :!""ÿÿ    R`x’ÆÜ      & 0 9!""ÿÿ                                  "àâäääääæêîòòòôôô  B S C D E F N G X H Q K Y P U 8 9 : ; < = > ? @ A J T O L M R _      	 
                    V I W Z [ o     ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 \ ` ] ^                                                                                     b         k           p   j           q r s                                                                   t                                                                               i h l m   e f   c d a g       n           Pã        P  þÎ  þì  ã  þ +        šã  
  “ÿ“ÿ¶þÚÿ³ÿ 6ÿ àãý   Ú  ÿ&  ãÿþÀ     J  à 1 A N                                                   Jc  %    
     
    ÿüÿüÿýÿõÿøÿôÿïÿ÷ÿìÿô           ÿÿÿÿÿöÿøÿ÷ÿæÿðÿòÿÜÿìÿñÿÝÿîþš c   ã 	        ÿîÿìÿÝÿ» ÿ:   ù  ,  ÿÿÿÿÿëÿÖÿÁà  ÿÿÿôÿ÷ÿùÿíÿõÿõÿçÿòÿîÿÚÿëÿóÿæÿóÿôÿèÿöÿïÿòÿùÿôÿûÿüÿõÿùÿùÿðÿ÷ÿôÿæÿòÿîÿÙÿìÿìÿØÿíÿëÿÛÿðÿòÿèÿøÿúÿøÿÿ  ÿ          "    /   þÉ  þý      $ -  % 3     *ÿì·õ g                                                                            OÿûÿïÿóÿòÿÜÿéÿäÿÍÿèÿáÿÇÿåÿíÿáÿôÿðÿêÿùÿùÿü   
        ! # $   + ) %       `ÿþÿõÿùÿöÿäÿïÿéÿÊÿãÿâÿÀÿàÿûÿèÿàÿÛÿîÿõÿêÿìÿïÿøÿéÿÚÿòÿðÿèÿ÷ÿ÷ÿòÿýÿþ       
  6 '  % ' )  $ G          
  )      ÿÿÿÿÿîÿòÿõÿâÿíÿéÿÊÿåÿäÿÄÿâÿâÿÄÿãÿïÿÝÿßÿäÿõÿõÿïÿõÿü   	       $ & ÿÿÿêÿÕÿëÿæÿÏÿëÿåÿØÿôÿôÿòÿþÿÿ       
 
   &   5    E # # C   & # !   1  	  
   ÿõÿóÿùÿñÿîÿéÿðÿéÿ½ÿÏ  S  ¯à  3                                       SG  . ) %   !    ÿÿÿ÷ÿúÿñÿìÿæÿîÿíÿ×ÿÒÿÌÿãÿ°ÿ_ÿ¯ c   Ü  $   
       ÿúÿùÿøÿéÿíÿóÿãÿßÿÚÿéà  ÿýÿôÿîÿçÿðÿìÿÑÿÍÿÊÿãÿÖÿ«ÿÕÿæÿËÿÎÿÑÿìÿéÿßÿéÿóÿý      ‹ýÉ         8    7 : 8   1     	   V  rÝ    ¹  ’  þn  ¹  ýä    „ÿ  ÿ©  ÿ	  ÿ«  Ý  ÿ§  V  Pà 	  P  þi  e  þ™  ÿŸ  àÿ¦  ÿ  ÿ«  þ°  à  ,ÿìËò u                                                                              aÿüÿöÿúÿùÿðÿöÿòÿÞÿíÿîÿ×ÿêÿàÿÉÿéÿèÿ×ÿîÿíÿæÿøÿøÿù                 '   +        
 
      ÿ  >  ÿÀÿèÿòÿäÿïÿðÿÙÿèÿêÿÎÿçÿçÿÏÿêÿçÿÍÿèÿèÿÔÿîÿðÿèÿ÷ÿøÿ÷        #   9 ! ! O 3  4   2        
  ÿÿÿôÿéÿôÿõÿèÿ      
       ÿ÷ÿöÿõÿàÿêÿëÿËÿãÿãÿÂÿáÿäÿÈÿæÿæÿÑÿíÿïÿçÿöÿ÷ÿñÿûÿøÿù              #   )    R  þ{   ^ÿðÿãÿôÿôÿëÿøÿùÿø  ÿÿ       *   :    F $ ( J ! " ?  ! /   ÿþÿþÿ÷ÿöÿ÷ÿåÿìÿúÿïÿìÿêÿõÿôÿéÿéÿëÿ÷            J  ‘à    ¯     c  ÿ›  þƒ  ÿ›  àþÌ  4  ý   X  þ¨  à  \   ¿à    \ c  ÿà  ý     ÿí´à 1                              ³ ÿÿÿòÿòÿòÿÕÿáÿêÿÍÿæÿæÿÎÿéÿçÿÚÿóÿóÿòÿþ     ]        
                        àýØÿâÿÇÿçÿçÿÙÿôÿùÿø     	   !   /  ( )  ÿÃÿöÿëÿöÿöÿìÿøÿøÿôÿüÿüÿû               M  £á    ¯  d ˆþÏ9ÿ€þþÿŽ  ÿž  áþ™g  þÖþI  qÿ“þü  á  M  $á    ¯  u  þ)  áýw  ÿ¨  á  H  á    Ô Ô Ñ   ÿŸ  ÿ4ÿžÿ.  ÿ¡  áý‘o  ý  iý—  \ý¤  á   M  ‘ä 	  ‘  ÿ”þˆ  ÿ    up  äý  Oý±  á  ý±R  $ÿìîõ / _                                                                  †ÿ×ÿ¶ÿàÿàÿÈÿéÿéÿÜÿôÿôÿó        "   7    I ( ( J " ! ;   '       ÿóÿôÿóÿÛÿéÿèÿÇÿßÿßÿ¶ÿ× # <   )          ÿ÷ÿøÿøÿçÿðÿðÿÖÿçÿçÿÄÿÞÿÝÿÆÿèÿéÿÚÿòÿòÿëÿúÿùÿú           '   ;ÿíÿÿ    ,   ? # " I % $ I " # ?   -       ÿôÿôÿôÿÜÿèÿèÿÄÿÜÿÜÿ¬ÿÑÿÐÿ«ÿÜÿÜÿÂÿèÿçÿÚÿóÿõÿò V      "   0   :   9   0   !       ÿðÿòÿòÿÙÿéÿêÿÍÿçÿæÿÎÿéÿéÿÍÿçÿæÿÎÿêÿêÿÚÿòÿóÿñ  X  yà  2                                  ®       &       ÿôÿôÿõÿÝÿë  ÿ÷ÿòÿïÿíÿïÿòÿ÷  ÿ  ÿœ   a   Ò  )        ÿüÿýÿûÿêÿñÿîÿÔÿìà  ÿýÿúÿøÿùÿôÿÜÿêÿèÿÉÿäÿãÿÉÿçÿêÿ×ÿð  ÿýÿûÿùÿúÿùÿûÿý    þÉ  àÿ©ÿ      	             	     $ÿÇîõ 8 k                                                                        †ÿ×ÿ¶ÿàÿàÿÈÿéÿéÿÜÿôÿôÿó        "   7    I ( ( J " ! ;   '       ÿóÿôÿûÿøÿùÿùÿøÿ÷ÿõÿóÿø cÿÌÿÿöÿéÿôÿßÿ¶ÿ× ! 9 ÿ± 4 b            ÿ÷ÿøÿøÿçÿðÿðÿÖÿçÿçÿÄÿÞÿÝÿÆÿèÿéÿÚÿòÿòÿëÿúÿùÿú           '   ;ÿíÿÿ    ,   ? # " I % $ I " # ?   -       ÿôÿôÿôÿÜÿèÿèÿÄÿÜÿÜÿ¬ÿÑÿÐÿ«ÿÜÿòÿëÿîÿòÿóÿõÿóÿóÿøÿ±ÿÆ Vÿúÿõÿûÿõÿò V    
 = =ÿ¸  
   0   :   9   0   !       ÿðÿòÿòÿÙÿéÿêÿÍÿçÿæÿÎÿéÿéÿÍÿçÿæÿÎÿêÿêÿÚÿòÿóÿñ  X  ¸ß + A                                             Ym  / , '    	ÿþÿúÿûÿïÿèÿãÿð     
         ÿ†ÿüÿûÿüÿÿ    ÿþÿòÿçÿÛÿèþò  ÿœ c      
   	  	     ÿüÿ÷ÿôÿ÷ÿòÿÚÿëß  ÿÿÿõÿíÿäÿïÿíÿÔÿÏÿÎÿèÿîÿßÿäÿèÿ÷ÿøÿãÿÕÿÈÿÞÿÄÿæÿØÿäÿîÿýÿð    * , )  )  )     þÆ  Šÿ        	 
              2ÿívò ‹                                                                                                    ÿÿÿûÿûÿüÿòÿöÿôÿâÿðÿðÿÞÿïÿîÿÚÿîÿîÿÞÿñÿòÿîÿûÿûÿý     	    ( ( )   ) ( &        ÿþÿøÿúÿûÿïÿéÿäÿñÿðÿÞÿÞÿÞÿðÿÖÿ±ÿÜÿÜÿÀÿäÿòÿéÿùÿùÿú  Y                  +        ÿþÿýÿûÿëÿðÿÞÿ·ÿÛÿÛÿ¶ÿÝÿÚÿÑÿóÿóÿõÿüÿþ 	  
    1   :   3   -      	 
      	       ÿýÿüÿüÿóÿ÷ÿøÿæÿðÿñÿßÿòÿôÿêÿ÷ÿöÿòÿüÿúÿöÿ÷ÿøÿüÿûÿ÷ÿóÿðÿöÿøÿéÿåÿàÿïÿîÿÜÿÚÿÛÿíÿôÿéÿêÿìÿ÷ÿøÿñÿ÷ÿùÿÿÿý  	  "   *   0   ÿêÿàÿòÿóÿåÿîÿûÿõÿ÷ÿøÿýÿýÿüÿþ     
 
       
           #   ,   2   +      ÿþÿþÿøÿùÿøÿçÿíÿñÿÙÿëÿêÿÔÿì    dá   d  ÿ  ÿš  ÿ  áÿ¥  ýz  ‰   X  Nÿíâ )                           ±     
 
    4   >          c  ÿþÿæÿìÿëÿËÿâÿØÿµÿÝÿÝÿ½ÿàÿäÿÏÿíÿíÿèÿþÿÿâþÿãÿ×ÿðÿðÿçÿõÿóÿðÿÿÿÿ   	    - ñ  ýúÿÜÿ¿ÿåÿåÿ×ÿôÿñÿñ        *   B %    “ã     Õ Ï pþõÿ—þóáýu  ý  á     ·ã    } ‰ ¥ n § ‰ nÿ=ÿ—ÿYÿTÿšÿ=ãý®R  ý®R  ý  cý  ã     •ã     ¼ ¸ zÿÿ„ÿ;ÿ1ÿŠÿáþê  þ—þ†  /þÑ  }d    •á   •þð  ÿŸ  þë s Ò ÏáþGþØ  (¹  þ¡_     Yá 	  W  þ?Ã  ý¾  ¾þb  áÿ«ýÎ  ÿ¦   U4   X  "ÿð' S r                                                                                      à        ÿöÿíÿôÿöÿëÿëÿíÿ÷ÿõÿ÷ÿþÿóÿäÿïÿêÿÌÿåÿçÿÐÿçÿåÿÑÿðÿ÷ÿú  	  	      , ( (     	  ÿÿÿøÿñÿìÿôÿçÿÉÿäÿîÿâÿóÿõÿöÿÿÿ¬   	         + + *   + !  ÿ¦ÿúÿðÿìÿëÿôÿòÿâÿâÿãÿòÿôÿêÿîÿóÿýÿÿ 	     * ) #  
  
   Xÿôÿõÿþÿý  ÿ¾ÿüÿýÿÿÿÿ        ÿôÿæÿ÷ÿòÿîÿýÿý  	 
 (   % % $       	      	          ÿûÿüÿðÿñÿôÿÝÿí    &        ÿÿÿûÿüÿûÿìÿâÿÙÿçÿkÿüÿùÿúÿüÿþÿýÿûÿúÿøÿûÿùÿõÿñÿêÿïÿìÿàÿéÿñÿýÿý    	        8ÿðß ) A                                               ”         ' & %   ,      ÿþÿõÿøÿöÿãÿêÿîÿÔÿãÿóÿâÿßÿßÿñÿòÿèÿêÿìÿø  ÿ©   æ $ 5     ÿëÿìÿíÿÇÿßÿßÿËÿîÿíÿì        6ßþö       ÿÿÿúÿúÿ÷ÿÞÿêÿêÿÌÿæÿäÿÇÿÇÿÈÿæÿãÿÊÿéÿîÿæÿøÿüÿý         ÿ¾  ßý_ÿý    O 1 0 K       ÿæÿçÿæÿ³ÿÎÿÍÿ¶ÿçÿçÿæ  ÿóè) M                                                       ÿåÿÐÿëÿÕÿâÿñÿèÿøÿøÿö  ÿÿ       )   8 !  +          ÿªÿÿÿíÿïÿïÿÑÿåÿëÿÝÿãÿéÿøÿ÷ÿôÿùÿý     
         0     [ÿøÿÙÿäÿòÿÞÿíÿîÿÖÿó   
   "  )   6   ;   1   #       ÿøÿùÿùÿëÿóÿóÿàÿîÿïÿØÿëÿÿ  *   ÿþÿÿÿõÿíÿèÿñÿñÿÝÿÜÿÙÿìÿîÿÝÿàÿâÿóÿóÿêÿðÿöÿÿÿþ    /  ÿÓÿµÿåÿóÿëÿùÿúÿù  ÿðöß ) G                                                     Y  ÿ¯  ÿøÿëÿçÿåÿóÿñÿßÿßÿâÿóÿãÿÔÿîÿêÿãÿöÿøÿõÿþ       ,   % & '      ÿs $ 4         ÿëÿîÿöÿäÿâÿÞÿðÿÞÿÍÿñÿøÿóÿ÷ÿü      5ß  ý!   Gÿôÿçÿëÿñÿüÿûÿû         6   8 9 9   4   " 	   ÿúÿúÿýÿîÿêÿçÿõþr      & +  2 L         ÿäÿæÿòÿàÿÜÿÖÿèÿÏÿ±ÿäÿåÿä  'ÿò- R g                                                                               ˆÿÿ                   [ÿýÿúÿøÿ÷ÿúÿëÿÚÿíÿóÿçÿæÿãÿïÿðÿÝÿÝÿÝÿñÿåÿ×ÿòÿòÿîÿûÿú           ,            
          	       þ}& ÿùÿùÿúÿíÿõÿèÿËÿçÿôÿèÿëÿíÿùÿóÿéÿøÿøÿ÷ ñÿðÿæÿèÿêÿôÿïÿèÿîÿôÿüÿý       * ÿÿÿòÿëÿîÿïÿ÷ÿâÿÛÿöÿøÿ÷ÿúÿýÿÿÿÿ   
   )   4   ;   .   ,    	        ÿÿÿýÿûÿüÿúÿ÷ÿøÿ÷ÿõÿôÿïÿìÿòÿ÷ÿèÿåÿãÿðÿéÿÐÿë G    $     	  ÿþÿÿÿûÿøÿõÿúÿôÿãÿïÿðÿÜ    ê                   W                   ÿ×ÿìÿôÿôÿû   Z  ÿ¦  ÿ¦  ÿº   Fj 	             ÿÿÿþÿÿÿ¯  ÿÿÿöÿ÷ÿîÿ¨  ÿ´  þ5  Ë   L     ÿ ï8 J n                                                                                   ‡         ' - 
  ÿýÿøÿëÿéÿèÿôÿîÿÓÿÐÿÓÿðÿÖÿËÿóÿúÿý          4 3 1         W    ÿüÿüÿûÿîÿóÿôÿàÿíÿëÿÏÿåÿèÿÏÿéÿèÿÔÿîÿïÿæÿøÿúÿû  Ýÿîÿàÿäÿéÿ÷ÿ÷ÿóÿ÷ÿü     
  	 	     # 8     ÿúÿóÿîÿöÿõÿèÿéÿèÿÈÿåÿÝÿöÿûÿúÿþ    1    2 ÿôÿîÿðÿôÿüÿøÿû     T 7  + + ,   ) ) % 
   ÿýÿùÿûÿñÿìÿèÿô E  ýâÿíÿÚÿðÿêÿÛÿðÿñÿæÿöÿõÿðÿüÿý          !  ÿ÷ÿïÿèÿòÿñÿßÿÝÿÛÿîÿîÿÛÿÝÿÞÿñÿñÿèÿîÿ÷    #   O ,  ) #         A  òà -                             ›          7   0          ÿ§    ÿüÿûÿûÿðÿõÿòÿÞÿïÿîÿÝÿðÿîÿäÿöÿúÿøÿúÿý    ÿ¦  àþð   	 	   
 ÿþÿþÿðÿôÿöÿèÿñÿîÿØÿíþv  n            ÿøÿøÿøÿãÿíÿ÷ÿéÿêÿëÿøþÄ  à  ?   œà     ? ]  ÿ£   ]  ÿ£  ýé  à  ÿ›   ÿîÿ* œà                     ? ]  ÿÿÿÿÿýÿûÿüÿüÿ÷ÿóÿíÿóÿñÿâÿñÿõÿëÿö   "          ]  ÿ£  ý•ÿùÿîÿïÿïÿøÿöÿðÿòÿõÿüÿüÿü       N      	   
4  ÿ›     B  þá    ™   á xÿ4 Øÿ‹ÿXÿ¸  ÿ©  áþS ã  ÿ:þ¯  ÿ¿ÿ6  á  @   ›ä    @ [  ÿ¥ä  ý    A  & ^                                                           ”           	  	   
              $  
   
                ÿ§  ÿÿÿøÿúÿ÷ÿäÿðÿðÿÝÿïÿôÿéÿöÿöÿòÿûÿûÿøÿÿÿÿÿ§    ÿ÷ÿùÿøÿèÿñÿðÿßÿïÿôÿæÿõÿöÿñÿúÿúÿö    ÿ¦   SÈ           ÿÿÿþÿþÿþÿõÿøÿúÿòÿøÿøÿñÿ÷ 
          ÿÿÿÿÿþÿÿÿýÿòÿöÿùÿíÿôÿ÷ÿèÿòÿöÿìÿõþx  q         ÿùÿüÿñÿ÷ÿ÷ÿêÿóÿõÿæÿóþª  {   
    ÿûÿûÿüÿñÿõÿ÷ÿæÿòÿòÿÞÿîþÃ       A  ô' /                               —          *   -   !         ÿ¥  ÿþÿùÿùÿúÿêÿñÿíÿãÿóÿöÿíÿïÿîÿ÷ÿõÿëÿ÷ÿ÷ÿõ    ÿ¦  ÿ´    
   
 
   ÿ÷ÿøÿùÿáÿíÿõÿçÿèÿìÿøþ{  f  "      ÿÿÿÿÿûÿùÿ÷ÿûÿúÿæÿðÿðÿàÿõþ¯    "ÿò,  G                                                           # :       ÿëÿìÿìÿÅÿÚÿìÿßÿãÿèÿöÿöÿñÿöÿû         
     ÿåÿÎÿÓÿÙÿïÿðÿçÿîÿ÷          & . 3   4 . '     	    ÿ÷ÿîÿæÿðÿðÿØÿÓÿÎ @      L 0 / M     ÿ÷ÿðÿçÿòÿñÿÝÿÛÿØÿíÿìÿÙÿÜÿàÿñÿòÿéÿðÿ÷ÿ²        , 2 7   8 3 .        ÿõÿëÿàÿìÿìÿÑÿÌÿÇÿãÿâÿÉÿÍÿÓÿíÿíÿáÿìÿõ  :ÿ.+ + O                                                             •ÿ¥   V              6  
       ÿùÿúÿúÿèÿïÿîÿÔÿåÿðÿÚÿÙÿÙÿíÿôÿëÿíÿíÿ÷ †ÿéÿÜÿäÿìÿøÿùÿ÷ÿûÿþÿÿÿÿ    : '      	        ÿýÿùÿôÿøÿ÷ÿéÿãÿÚÿ.  é  ÿ³       	 ÿÿÿýÿúÿâÿçÿõÿäÿâÿâÿñÿæÿÑÿÑÿÐÿåÿäÿÉÿèÿèÿÙÿõÿùÿøÿý       œÿÿÿôÿëÿåÿñÿðÿßÿßÿàÿòÿÓÿ´ÿäÿåÿâ        " $ %   # # !       #ÿ-÷' . R                                                            ÷  ÿ§  ÿúÿôÿòÿðÿöÿðÿÐÿåÿóÿäÿåÿçÿôÿìÿÞÿóÿòÿìÿøÿúÿøÿÿÿÿ           *   ,        ÿq ! 8   ÿþÿÿÿýÿúÿ÷ÿøÿùÿìÿäÿÜÿéÿêÿÚÿâÿéÿøÿ÷ÿõÿùÿý        
 
   ý  ÿùÿòÿòÿôÿúÿùÿ÷              ,   9   1   ,   "     ÿýÿüÿüÿïÿêÿæÿó Kþ'     C )  ) % #       ÿùÿðÿéÿòÿñÿÞÿÚÿ×ÿëÿëÿØÿÛÿßÿòÿóÿêÿñÿú   M  R%                  £     	          ÿïÿáÿåÿóÿçÿöÿöÿïÿúÿúÿøÿÿ  ÿ¦  ÿ£   
    	     ÿ   ÿþÿ÷ÿüÿôÿøÿùÿíÿõÿõÿçÿóþ´     ÿîÙ& e                                                                                qÿþÿûÿüÿùÿèÿãÿßÿïÿòÿäÿåÿéÿøÿùÿú     ,   <   &     ÿÿÿ÷ÿîÿõÿõÿäÿàÿÝÿïÿÞÿµÿÜÿðÿßÿãÿéÿøÿúÿ÷ÿúÿüÿþ Y      " ( +       ÿþÿ÷ÿñÿîÿìÿëÿìÿøÿàÿÉÿÐÿ×ÿïÿôÿóÿû   	  ' -   7 5 /     	            ÿüÿøÿòÿöÿøÿèÿçÿìÿüÿôÿñÿûÿùÿôÿöÿùÿëÿóÿôÿäÿïÿïÿÚÿÚÿÜÿòÿòÿêÿïÿöÿýÿú             ÿëÿÜÿðÿóÿðÿ÷     	        
             # $   '      ÿ÷ÿìÿðÿôÿäÿáÿÞÿï  ÿò´                ª   X  ÿ¨         
 ,  ÿòÿâÿñÿìÿÚÿñÿöÿñÿúÿúÿøÿÿÿÿÿ¸   H  ´ÿo  ÿ¨  þ¦ÿöÿðÿúÿ÷ÿù  ÿ°ÿÿÿý          
  †   Z      Gÿéò *                            ò  ÿ¦  ÿ÷ÿéÿçÿäÿòÿéÿÛÿßÿáÿîÿìÿÞÿæÿð     Y        %   "               ýã   7ÿ÷ÿíÿïÿòÿüÿùÿùÿÿ     & -    þnÿíÿáÿõÿóÿò    
 	 	   
       N     ó   óÿ5ÿ¢ÿ< h Œ ˜ýç    þG¹     Ñ   Ñÿfÿ¤ÿ’ÿ—ÿ£ÿf a g h e l jýé  ¢þ^    þ`   þ^    	  ó   êÿN »ÿÿ}ÿ}ÿ ½ÿO s { |þûþî   Ëÿ5    ÿF º  
ÿ$ò #                        òÿÿýÿùÿ÷ÿöÿúÿûÿôÿóÿñÿ÷ÿôÿàÿðÿöÿíÿïÿòÿü     
    
    ÿ8 d “ ýÿúÿîÿëÿéÿõÿ÷ÿïÿòÿõÿýÿûÿú  ÿÿ     Oÿýÿüÿÿ        3 +  þJ¶     Þ 	  Ô  þÂH  þB  @þØ  ÿ´þ  ÿ´   H…   L  ÿò	Ø ' O                                                                    $           ÿüÿøÿóÿ÷ÿ÷ÿèÿãÿÝÿìÿëÿÝÿäÿêÿ÷ÿøÿôÿøÿý        	    $ ÿÛÿÃÿÏÿÚÿòÿòÿíÿôÿú      	    $ 1 @ ) ( A 2 %    	     ÿûÿõÿîÿóÿòÿÜÿÐÿÄ D    "   / 3 6   6 3 .        ÿÿÿóÿéÿàÿìÿìÿÒÿÎÿËÿäÿåÿÉÿËÿÐÿëÿëÿÞÿèÿôÿ°     ,   9 ; <   > A A   4 &    ÿíÿÜÿÏÿãÿäÿÀÿÀÿÂÿäÿåÿÃÿÂÿÄÿäÿåÿÒÿÞÿî  d  kÏ         k  ÿž  ÿ[    /   "  
  Ïý1     G         $      Ñ N                                                              þ         "   8 9 8    ÿýÿùÿøÿãÿÙÿÏÿäÿóÿçÿèÿëÿöÿ÷ÿôÿùÿýÿÿÿ¦  
   $   0  ! A   +    	  ÿúÿöÿ÷ÿÛÿåÿóÿãÿâÿáÿòÿñÿáÿãÿåÿóÿôÿêÿïÿôÿü Tÿ¬         % "     "   "   $ * .      	ÿþ  ÿøÿóÿîÿõÿóÿâÿßÿßÿð   # @   +     ÿþÿùÿøÿéÿäÿßÿíÿîÿÙÿÓÿÏÿäÿæÿÏÿëÿöÿíÿîÿïÿøÿ÷ÿðÿðÿðÿöÿ÷ÿëÿçÿâÿî   "ÿòÙ p                                                                                   Šÿ¨        %   -   4   ,  	       ÿõÿõÿûÿòÿðÿîÿõ ! /  	 	  ÿÿÿ÷ÿøÿõÿäÿðÿìÿÓÿéÿìÿØÿëÿæÿÊÿäÿäÿ×ÿñÿôÿíÿùÿûÿùÿûÿü   ]ÿÿ   	           1 ! ÿýÿþÿìÿÛÿÉÿÛÿÊ   8  &     ÿùÿñÿõÿõÿâÿßÿÜÿðÿñÿãÿçÿëÿùÿøÿ÷í    *   -         ÿöÿ÷ÿõÿáÿíÿöÿæÿãÿáÿðÿçÿÐÿìÿöÿñÿòÿõÿúÿõÿÓÿßÿéÿËÿçÿçÿÔÿñÿíÿÞÿóÿîÿçÿúÿúÿúÿÿ     	            ÿáÿÍÿìÿóÿîÿóÿ÷ÿûÿÿ       ' 4   *      K         ! !     	 ÿýÿþÿõÿîÿèÿïÿîÿØ     Ï 
     ÿ—  ÿ¥  þÆ  G N  ÿ¥  ÿ ýÿ²  ÿQ   ¯   YÇ  þ. Cþ½  ÿòÆ N                                                    ã  þÎÿã  ( - /   2   &     ÿõÿòÿ÷ÿÙÿæÿçÿÆÿäÿçÿËÿèÿçÿÒÿìÿìÿáÿõÿõÿñÿü ^   	  	 	    	  $   "      ÿüÿýÿðÿôÿõÿáÿïÿîÿÚÿîÿïÿÛÿïÿðÿåÿùÿ® 5Æÿ¦  ÿ@    ÿüÿüÿïÿóÿôÿÞÿëÿåÿÇÿâÿâÿ½ÿÛÿåÿÕÿðÿðÿëÿüÿü            .   ÿóÿèÿéÿíÿøÿøÿöÿúÿüÿÿÿý       &   )   &      ÿÿ  ÿõÿøÿ÷ÿéÿó    #ÿòÑ ` x                                                                                      ©ÿüÿ÷ÿùÿúÿïÿôÿõÿãÿâÿâÿóÿðÿåÿèÿìÿùÿ÷ÿôÿúÿýÿÿ     	  "   %   /   %      ÿüÿûÿíÿòÿóÿÝÿëÿðÿÖÿêÿêÿÓÿêÿëÿÕÿìÿìÿÝÿôÿíÿçÿøÿùÿùÿþ               9   /   .    	 	 	  ÿ"  4     ÿëÿíÿìÿÇÿÝÿÞÿÌÿîÿîÿî        4        	 ÿüÿûÿúÿìÿçÿäÿñÿíÿÖÿÕÿÑÿè 
     
     ÿýÿüÿðÿôÿôÿßÿêÿïÿÙÿëÿëÿÖÿìÿæÿÍÿèÿèÿ×ÿðÿóÿòÿýÿý          :   ?    $ !     =      
      ÿûÿûÿìÿñÿôÿâÿîÿîÿÖÿæþ/      : & & <       ÿçÿëÿêÿÆÿÞÿßÿÇÿëÿëÿé   %  ¿ 4                                    ÿòÿäÿòÿóÿäÿóÿõÿíÿ÷ÿöÿïÿùÿ÷ÿðÿùÿóÿêÿöÿúÿõÿûÿýÿúÿýÿ¡        	   
  	    !   %    þv  ¿ÿ®ÿðÿÝÿîÿíÿÚÿìÿðÿàÿðÿðÿàÿðÿîÿÛÿíÿßÿ»ÿÝÿëÿÕÿëÿóÿæÿô    ,   +         *   8   5  	  	   Z   #ÿñÙ  3                                                                                             /   ÿÿÿþÿéÿíÿíÿÏÿãÿäÿÕÿòÿñÿó        . % $ 8       ÿîÿíÿîÿÇÿÞÿÝÿÊÿíÿìÿë        	 	   ! Œ 
      	     ÿóÿðÿøÿìÿõÿõÿæÿóÿêÿÌÿåÿäÿÉÿæÿöÿëÿëÿëÿ÷ÿöÿðÿòÿ÷ÿþÿöÿñÿýÿý       # ÿîÿãÿõÿõÿñÿýÿù    %   D # $ D   #   	ÿüÿþÿñÿõÿõÿá¨      ,   )   ÿÿ  ÿìÿïÿðÿÕÿëÿêÿÛÿñÿñÿïþœ      3   3   ÿÿÿþÿñÿïÿïÿÍÿÜÿïÿâÿçÿêÿöÿöÿòÿ÷ÿüCÿúÿïÿõÿöÿçÿòÿèÿÍÿæÿåÿËÿçÿóÿèÿõÿõÿíÿùÿôÿñÿýÿþ  	  	          0   1   "     
        ?   .       ÿïÿðÿóÿØÿçÿçÿÆÿâÿîÿßÿòÿòÿè  *ÿíÑ  p                                                                               ÿÜÿÉÿîÿíÿî      4 & % 7       ÿîÿîÿîÿÌÿO                  	    ÿñÿåÿòÿòÿÞÿëÿêÿ×ÿëÿìÿÙÿíÿóÿáÿòÿðÿêÿýÿýÿþ    
     -  & P %  -    	    ÿÿÿúÿûÿúÿðÿõÿôÿ×ÿäÿëÿÍÿäÿîÿÔÿèÿéÿÑÿëÿðÿçÿ÷ÿõÿõ  ‚  ÿçÿëÿêÿÇÿàÿÛÿÃÿëÿêÿè        < "   :   þ+ÿùÿðÿñÿñÿúÿæÿñÿøÿöÿý         % ' + ÿïÿêÿøÿøÿôÿúÿúÿþ         .   .   ,   $     ÿüÿóÿöÿáÿëÿæÿºÿÖÿãÿÁÿÞÿàÿÄÿãÿãÿÆÿâÿßÿÆÿêÿðÿêÿûÿý           .    Kÿò Îù  .                                   Œÿóÿèÿ÷ÿ÷ÿö     
 	 	     	 	 
    ÿöÿ÷ÿ÷ÿè 5  ÿÙÿÿÿûÿùÿ÷ÿöÿ÷ÿùÿûÿÿÿÚ            ÿò   
  	     	 	 
    ÿöÿ÷ÿ÷ÿéÿòÿóÿèÿ÷ÿøÿöïþüþÔÿüÿùÿüÿþ     )  	      ÿúÿ÷ÿø     Á    ÿá ~  Hÿà jÿ÷ÿ–ÿê iÿ÷ÿ™ÿãÿ¼ ÿ‚ÿãÿ¼ ÿ–  h ÿ˜ 	 l  žÿ‚ÿé ~¼ÿ.   ×  ÿ)  ÿº  ÿw  ÿ¼  ÿ)   ×  ÿ)   Ô   D      F   Ôþæ  ÿq    ÿ‹ o }                                                                                                 °ÿÿÿûÿüÿüÿôÿøÿöÿæÿòÿûÿ÷ÿöÿõÿø       # " !        ÿÿÿùÿúÿüÿòÿìÿèÿòÿóÿãÿâÿâÿóÿüÿöÿü  ÿÐ  ÿîÿÝÿïÿáÿÈÿéÿóÿíÿúÿùÿû  N                ÿãÿÏÿèÿßÿ×ÿõÿôÿöÿþÿý 	 	 	    *       1   K  %       ÿÿïÿÝÿáÿçÿúÿúÿþ     "  0    ' $    ÿÿÿúÿúÿöÿãÿàÿÝ              ÿÿþÿÿÿÿÿüÿöÿôÿðÿöÿøÿéÿåÿáÿïÿïÿÜÿÛÿÛÿîÿôÿéÿëÿìÿøÿ÷ÿòÿöÿúÿþ      ÿœ   c     "   *   /   ÿêÿàÿóÿóÿæÿîÿûÿõÿ÷ÿøÿýÿÿÿüÿÿ     "   +   1   *        4 ÿÉÿïÿüÿäÿîÿñÿÙÿëÿëÿÕÿì ™  ÿ÷ÿìÿâÿíÿëÿÔÿíÿíÿèÿïÿöÿüÿ—þü     !  
    	      #ÿíWÐ   3 O m                                                                            ¤þpÿÈþf  '       ÿðÿñÿòÿÙÿêÿëÿÙÿòÿñÿð        'ì  &       ÿïÿòÿñÿÚÿêÿêÿÚÿñÿòÿï        &þ?ÿÜÿÀÿéÿèÿä          @ $ $ @       ÿäÿéÿôÿäÿàÿÞÄÿÜÿÁÿèÿèÿå          ? $ % ?         ÿåÿèÿôÿäÿáÿÝÐý  ãþá      '   '       ÿðÿñÿòÿÙÿêÿëÿÙÿòÿòÿïþ†      &   '       ÿðÿñÿòÿÙÿêÿêÿÚÿòÿñÿð4      @ $  "          ÿäÿéÿèÿÀÿÜÿÜÿÀÿèÿôÿíÿóÿùþ‡      @ $  "         ÿäÿèÿôÿäÿáÿÞÿîÿÜÿÀÿèÿôÿíÿôÿù  *ÿñ’à I g ~                                                                                      ’ÿŒÿ¹ÿïÿÞÿîÿíÿÛÿÙÿÙÿìÿÞÿÅÿçÿëÿßÿõÿõÿõ  ÿÿ  
       & ÿ÷ÿíÿøÿõÿîÿûÿú  	 	 !   4      	   	  ÿûÿúÿæÿïÿïÿ×ÿë … 
   Tÿþÿöÿùÿøÿíÿõÿ       	 ÿüÿüÿñÿöÿùÿèÿòÿòÿãÿõÿòÿðÿþÿý     	  ÿèÿâÿÏÿðÿïÿð   
          %          Sÿíÿâÿóÿôÿóÿùÿý  ÿÿ    %   0   1      	        "   5   +       ÿýÿúÿ÷ÿúÿóÿÚÿéÿêÿÎÿèÿæÿÕÿîÿîÿàÿñÿa  ;   ÿèÿÏÿèÿèÿÒÿë" 
  
 
    "         ÿûÿùÿøÿäÿñÿñÿàÿóÿõÿéÿõÿöÿêÿÿñÿÙÿêÿéÿÐÿçÿñÿåÿêÿíÿùÿùÿöÿû      	 	     Dÿ/1ò %                          .ÿåÿÒÿîÿñÿéÿûÿüÿý           - ÿÆÿãÿÊÿéÿìÿâÿøÿùÿø       
    1 òÿÓÿ¦ÿÒÿÖÿ©ÿÐÿãÿÆÿâÿÛÿµÿÛÿÒÿ­ÿÚÿÓÿ¬ÿÕ   - S + & P / & I $  ?  - ^ - - W '  '¹dà    ã   k ÿ FÿÎÿ»ÿÀÿÍ Cÿ”  k  àÿŽ (ÿÇÿÝÿ£ÿÜ _ÿ£ ! _ # 8ÿØ r  ÿëÿî-ô   ÿë D þÿ¹ô  üú    T   Æ  /                                   ÿôÿëÿùÿøÿ÷     	         	    ÿ÷ÿøÿøÿìÿôÿôÿëÿùÿøÿ÷     	         	    ÿ÷ÿøÿøÿì¡   
         	    ÿ÷ÿøÿùÿëÿôÿõÿëÿøÿøÿ÷þ_            	    ÿ÷ÿùÿøÿëÿõÿôÿëÿøÿùÿø  Sÿt Ç V %                           Œ    ÿÿÿþÿþÿ÷ÿíÿøÿøÿö     	         	  ÿûÿøÿóÿùÿøÿñÿòÿôÿüÿ÷ÿö ÿå     ÿÿÿú     	     	    ÿ÷ÿøÿùÿëÿôÿõÿèÿçÿèÿôÿõÿêÿíÿñÿú  
 .  ( w+‘     (  ýý    ýý‘  ÿ´  ÿ}  ÿµ    . !ú    .ó  þ  Œþtúÿ/ÿ¶ÿ- R ¦ ¦   84 Ÿì +                                   jÿþÿûÿûÿüÿþÿþÿüÿüÿüÿÿÿüÿùÿþÿþÿþ         
         ÿÿÿþÿÿÿüÿþÿþÿüÿûÿûÿýÿþÿúÿúÿù4       	   
   	     
    	    ÿ÷ÿùÿùÿíÿöÿüÿ÷ÿüÿüÿùÿýÿþÿôÿñÿîÿøÿ÷ÿïÿóÿù  . !ú   !  þtŒ  þ  úÿ°ÿZÿZÿ® Ó J   Tÿò Æ c                    ÿôÿëÿùÿøÿ÷     	         	    ÿ÷ÿøÿøÿìÿò   	         	    ÿ÷ÿøÿøÿìÿôÿôÿìÿøÿùÿ÷  ( )   )  ÿ%  ÿµ  ÿ%   Û   K  (ÿµ  ÿ$   Ü   M   Ú  ÿ$  5  ïë J b                                                                            ?ÿ¦                   ÿ÷ÿíÿâÿêÿèÿÔÿÙÿáÿöÿøÿöÿúÿýÿþÿ§            $ ' '   % #          ÿõÿðÿìÿ÷ÿöÿçÿçÿçÿ÷ÿúÿøÿúÿüÿþÿþ ÿÏÿõÿëÿøÿùÿö     
         	    ÿ÷ÿøÿùÿë ¾         & "       !   ) %   ÿýÿòÿéÿñÿôÿæÿäÿâÿñ            	 	   ÿÿÿÿÿøÿòÿëÿóÿïÿÛÿ×ÿÕÿéÿñÿâÿäÿåÿóÿòÿçÿèÿèÿñÿøÿíÿìÿëÿöÿõÿêÿ6            	    ÿ÷ÿùÿøÿëÿõÿôÿëÿøÿùÿø   840ì * V                                                                  ûÿýÿüÿûÿûÿþÿþÿüÿýÿüÿþÿüÿúÿþÿþÿý              	    ÿþÿÿÿýÿûÿÿÿûÿüÿûÿýÿýÿúÿúÿúÿlÿþÿûÿûÿüÿþÿþÿüÿüÿüÿÿÿüÿùÿþÿþÿþ         
         ÿÿÿþÿÿÿüÿþÿþÿüÿûÿûÿýÿþÿúÿúÿù4       	   
   	     
    	    ÿ÷ÿùÿùÿíÿöÿüÿ÷ÿüÿøÿúÿýÿõÿñÿîÿøÿ÷ÿïÿóÿù         	   
   	     
    	    ÿ÷ÿùÿùÿíÿöÿüÿ÷ÿüÿüÿùÿýÿþÿôÿñÿîÿøÿ÷ÿïÿóÿù   SÿŽ Ç  =                                           Œÿôÿëÿùÿøÿ÷     	         	    ÿ÷ÿùÿøÿëÿô    ÿÿÿþÿþÿ÷ÿíÿøÿøÿö     	         	  ÿûÿøÿóÿùÿøÿñÿòÿôÿüÿ÷ÿö     
         	    ÿ÷ÿøÿøÿìÿôÿôÿëÿøÿøÿ÷þ^     ÿÿÿú     	     	    ÿ÷ÿøÿøÿìÿôÿôÿèÿèÿèÿôÿôÿëÿíÿñÿú 
  . ÿëÿî-ô   -ÿÿº þôüú    ?ÿ9 ÿà    ü  ÿ”   o  ÿ@  àÿº  üè  ÿ·  §  ÿ9 Ûà     ½  ÿ@   o  ÿ”à  üY   I       ÿ/ò %                           # =  2    
      ÿùÿùÿ÷ÿßÿêÿêÿÍÿäÿÇ  -         ÿýÿüÿúÿçÿïÿîÿÕò  ÿÙÿ©ÿÓÿÓÿ¢ÿÓÿÞÿ¾ÿßÿÞÿ»ÿÜÿÎÿ«ÿØÿØÿ±ÿÖ   + T - & S . ! B " ! C ! 3 ] , + T  , î'J    , û  ÿJ  ÿ¤   ÿðéÂ    Ùÿ²ÿQÿRÿ² ÚÂþL  _þ£  ²    ÿ‚7ÿµ     7  ýÉÿµ  ÿÍ    'ÿ6(æ E                                            (  ÿÑÿ÷ÿïÿùÿùÿø      ÿòÿóÿõÿãÿï                   7  ÿ´ÿöÿìÿíÿîÿùÿõÿò      ÿõÿõÿöÿâÿí   
                    $  !åÿ»    ÿõÿøÿ÷ÿìÿ÷ÿ)ÿçÿØÿðÿñÿèÿöÿøÿçÿñÿõÿêÿêÿìÿøÿ(ÿ÷ÿíÿøÿøÿõ    ÿº        	  !  â  %     :            æ             'ÿ6(æ E                                             ' #    $                    
  ÿîÿáÿöÿõÿõ      ÿóÿôÿùÿîÿíÿìÿöÿ´   7                  ÿðÿâÿõÿóÿò      ÿøÿùÿùÿïÿ÷ÿÑå     ÿòÿôÿøÿíÿëÿëÿõÿÿùÿïÿîÿïÿøÿøÿòÿõÿú  ÿÆÿýÿéÿðÿðÿÛÿïÿÿñÿßÿñÿ÷ÿðÿõÿù     F         	 Ø         
    (  × 	  	        = ¸N 5                                        ÿúÿòÿñÿðÿöÿëÿÎÿèÿîÿàÿïÿïÿÞÿîÿ÷ÿìÿìÿíÿøÿøÿôÿöÿ÷ÿûÿûÿõÿùÿÜ   
    
      '   %      
   	ÿ÷ÿíÿïÿðÿúÿóÿö     	       ÿüÿýÿùÿøÿöÿùÿúÿîÿô ;   	     ÿÿÿüÿýÿúÿíÿ÷ÿ÷ÿðÿþÿÿÿÿ        ”ÿíxõ ¶ Ò                                                                                                                                                                    Œ      	           ÿýÿ÷ÿøÿðÿÓÿÃÿ²ÿÎÿáÿÀÿÄÿÊÿéÿëÿÝÿèÿó   0 0  / 2 5   - , +       @ÿòÿÐÿâÿðÿÝÿÛÿÛÿîÿÝÿ¸ÿ¾ÿÈÿíÿàÿÆÿçÿêÿÛÿòÿëÿñ     	  ! (   2 8 ;   " 8 0 '         
 ÿýÿýÿóÿðÿïÿøÿüÿíÿçÿáÿÝÿÜÿÝÿßÿñÿöÿó ÿóÿäÿïÿìÿÏÿèÿêÿÖÿíÿéÿÝÿ÷ÿûÿÿ    
      & $ #       ÿìÿìÿîÿÙÿÙÿÚÿïÿôÿòÿüÿ·   	 
      & & #   #  ÿþÿ›ÿôÿÛÿìÿõÿèÿçÿæÿæÿéÿëÿðÿûÿü      & % "  
     ìÿýÿøÿøÿùÿüÿÿ      ! $   1 . '    7 )   ÿ÷ÿéÿÜÿçÿèÿÍÿÇÿ¿ÿÚÿ¶ÿ‰ÿÔÿëÿâÿìÿôÿýÿþ    	       ÿâÿÉÿêÿôÿëÿîÿôÿüÿù   
  	  '   7 " 0 d 0 * P !  $ # "     ÿýÿþÿõÿòÿîÿõÿõÿçÿãÿßÿîÿîÿÔÿÑÿÐÿéÿæÿÑÿÚÿáÿöÿúÿìÿéÿçÿìÿñÿû   	  ÿ÷ÿîÿûÿ÷ÿø   
   )   !          ÿÿÿüÿû          )  	  ÿ÷ÿñÿ÷ÿãÿð        
  ÿþÿúÿõÿùÿøÿèÿáÿÚÿêÿÿúÿý        ÿÿÿûÿøÿóÿîÿóÿïÿãÿéÿïÿûÿúÿþ  
   
   	   ]ÿò £ñ    ] F  ÿºñ  ý    ) õ*ö                    ©ÿæÿÑÿîÿïÿì        /   /       ÿìÿîÿïÿÑ õ      /   /       ÿìÿîÿïÿÑÿåÿæÿÑÿïÿîÿì ÿõÿöêë H p ˜                                                                                                                  tÿéÿ×ÿîÿîÿàÿóÿôÿëÿùÿùÿø  ÿÿ       #   0   %     
     ÿ·ÿÿÿïÿòÿòÿØÿéÿîÿâÿçÿíÿùÿñÿô   
   + "  )     MÿúÿßÿèÿôÿãÿðÿðÿÝÿè ! > 9 3   "      ÿóÿèÿÞÿêÿëÿÍÿÇÿÂÿßÿßÿÂÿÇÿÍÿëÿêÿÞÿçÿó       "   3 9 > !ÿÙÿ¶ÿ»ÿÄÿæÿæÿ×ÿãÿò       )   < E J ' ' J D =   )      ÿñÿãÿ×ÿæÿæÿÃÿ¼ÿ¶ ~        #   .   2   *    
 
     ÿùÿúÿúÿîÿõÿõÿåÿñÿñÿÞÿîÿÿ  $   ÿÿÿÿÿöÿñÿêÿôÿæÿÀÿÞÿâÿÇÿêÿêÿäÿýÿÿ    (   ÿÚÿÀÿêÿôÿîÿúÿúÿúÿµ     "   3 9 > ! ! > 9 3   "      ÿóÿèÿÞÿêÿëÿÍÿÇÿÂÿßÿßÿÂÿÇÿÍÿëÿêÿÞÿçÿôÿÃ     )   < E J ' ' J D =   )      ÿñÿãÿ×ÿæÿæÿÃÿ¼ÿ¶ÿÙÿÙÿ¶ÿ»ÿÄÿæÿæÿ×ÿãÿò   ,ÿa
ß   K   ¿  ÿA  ÿŸ  ÿB   ¾  ßÿ'  ÿµ  ý¦  Z   O   Õ  +ÿaß   K   ¿  ÿA   À  ÿ@  ÿŸ  ÿA   ¿  ÿB   ¾  ßÿ'  ÿµ  þ¾  ÿ³ÿÿÿ6   Ë   M  B   O   Õ  >átÅ % K                                                   xÿÿÿÿ      	    
    ÿ÷ÿùÿøÿëÿôÿôÿìÿùÿùÿöÿÿÿÿ  	        
 	ÿé ¬ÿþÿÿ      	    
    ÿ÷ÿøÿøÿëÿõÿôÿìÿøÿùÿöÿÿÿÿ  	        	 	ÿéTÿýÿúÿýÿýÿý  ÿûÿúÿùÿìÿøÿôÿëÿøÿøÿ÷     	              ÿõÿõÿÓÿÒÿýÿúÿýÿýÿý  ÿûÿúÿùÿìÿøÿôÿëÿøÿøÿ÷     	              ÿõÿõÿÓ  2ÿhã % K                                                  .    ÿÿÿþÿþÿ÷ÿíÿøÿøÿö     	         
  ÿüÿ÷ÿôÿøÿùÿñÿòÿôÿüÿöÿ÷ ÿT  ÿÿ  ÿýÿþÿ÷ÿíÿøÿøÿö     	         
  ÿüÿ÷ÿóÿùÿùÿðÿòÿôÿüÿ÷ÿ÷ p     ÿÿÿû     	     
    ÿöÿùÿøÿëÿôÿõÿçÿèÿçÿôÿõÿêÿíÿñÿú  
 . .     ÿÿÿû     	     
    ÿöÿùÿøÿëÿôÿõÿçÿèÿçÿôÿõÿêÿíÿñÿú  
 .  pÿòˆ c  / G                                                  üÿôÿìÿøÿøÿ÷     	         	    ÿ÷ÿøÿøÿìGÿôÿëÿùÿøÿ÷     	         	    ÿöÿùÿøÿìýNÿôÿìÿøÿøÿ÷     	         	    ÿ÷ÿøÿøÿìÿò   	         	    ÿ÷ÿøÿøÿìÿôÿôÿìÿøÿùÿ÷     	         	    ÿ÷ÿøÿøÿìÿôÿôÿìÿøÿùÿ÷     	         	    ÿ÷ÿøÿøÿìÿôÿôÿìÿøÿùÿ÷  FK    F½  ýCK  ÿÀ    FŒK    FF  ýºK  ÿÀ    ÿMûß               ûÿµ  ÿ…  ÿµ  ÿÞÿËÿëÿåÿØÿïÿòÿó        &   4  ÿM  U  ü®     
  &   2   3          ÿõÿöêë ' O w ‰                                                                                                    o ! > 9 3   "      ÿóÿèÿÞÿêÿëÿÍÿÇÿÂÿßÿßÿÂÿÇÿÍÿëÿêÿÞÿçÿó       "   3 9 > !ÿÙÿ¶ÿ»ÿÄÿæÿæÿ×ÿãÿò       )   < E J ' ' J D =   )      ÿñÿãÿ×ÿæÿæÿÃÿ¼ÿ¶ÿ- Û  5  	  ÿþÿýÿýÿöÿñÿïÿö           	   ÿ·ÿýÿýÿþÿÿ    ÿþÿâÿãÿ^  ÿÄ ;          
 
    ÿöÿöÿ÷ÿêÿó 3     "   3 9 > ! ! > 9 3   "      ÿóÿèÿÞÿêÿëÿÍÿÇÿÂÿßÿßÿÂÿÇÿÍÿëÿêÿÞÿçÿôÿÃ     )   < E J ' ' J D =   )      ÿñÿãÿ×ÿæÿæÿÃÿ¼ÿ¶ÿÙÿÙÿ¶ÿ»ÿÄÿæÿæÿ×ÿãÿòV  ÿÿÿèÿëÿõÿæÿãÿáÿòÿõÿìÿðÿòÿúÿûÿïÿæÿßÿëÿÜÿðÿèÿïÿöÿþÿö   
    	  ! !   ÿC  †ÿj              	 	    >á ±Å %                           xÿÿÿÿ      	    
    ÿ÷ÿùÿøÿëÿôÿôÿìÿùÿùÿöÿÿÿÿ  	        
 	ÿéTÿýÿúÿýÿýÿý  ÿûÿúÿùÿìÿøÿôÿëÿøÿøÿ÷     	              ÿõÿõÿÓ  2ÿ ¦ã %                           k  ÿÿ  ÿýÿþÿ÷ÿíÿøÿøÿö     	         
  ÿüÿ÷ÿóÿùÿùÿðÿòÿôÿüÿ÷ÿ÷ p     ÿÿÿû     	     
    ÿöÿùÿøÿëÿôÿõÿçÿèÿçÿôÿõÿêÿíÿñÿú  
 .  ,<Yã    ‚  ÿq  ÿÅ  ÿt  é z x R  ÿÈ  ÿ‹ÿÇÿˆ  ÿÊ  ãÿÌ  þ  u   2  þ›e  þY  bþž  Zþ¦  §   b ×ï    { \ÿ»ÿ|ïÿs     {bDï    × mÿ|ÿ»ï  ÿs    Pÿñ÷             °þ$ÿ¹Þþ‡  ÿÃ  ÿ›          	 :  ÿ½  ÿÆ  ÿ8   Ð 2  ÿÆ  ÿn÷üú  ÿÛþE  <   ,        	  ýÆÿÏ  ÿ‘   o   9!  þ×  Íÿ3   Pÿñö÷   U                                                      °þ$ÿ¹Þþ‡  ÿÃ  ÿ›          	 /  þñ     !         ÿþÿýÿüÿðÿêÿåÿðÿòÿæÿõÿûÿúÿüÿþÿÿÿÏ           $         ÿýÿûÿûÿëÿòÿñÿÞÿðÿïÿßÿóÿòÿìÿý÷üú  ÿÛþE  <   ,        	  ý_ÿÒ    #   %               ÿÿÿÿÿñÿôÿùÿïÿîÿîÿ÷    #    	    ÿÿÿüÿûÿôÿðÿîÿöÿöÿêÿèÿäÿñÿòÿåÿôÿõÿìÿ÷ÿ÷ÿïÿõÿöÿåÿì  ÿñ÷÷ d o r v                                                                       WÿÌ        
           	 
 
    ÿúÿùÿúÿíÿó       ÿÿÿûÿûÿúÿïÿ÷ÿôÿåÿòÿõÿèÿóÿñÿàÿïÿðÿçÿ÷ÿùÿõÿûÿûÿúÿÿ 7     
        	ÿÿÿþÿôÿêÿàÿêÿà   !       ÿüÿ÷ÿúÿùÿîÿìÿëÿ÷ÿîÿàÿøÿûÿû   ÿÃ  ÿË  ÿK   ½ -  ÿË  ÿ| ¯þ$ÿ¹ÞG         
        ÿúÿûÿùÿîÿõÿôÿÜÿíÿñÿäÿôÿõÿðÿúÿùÿåÿíÿòÿáÿñÿñÿæÿ÷ÿõÿìÿøÿõÿñÿüÿýÿü  ÿÿ     	     #   ÿîÿâÿóÿòÿñÿú           
    ,       	       
  ÿÿÿýÿëÿíÿöÿèþ>ÿÓ  ÿ›   e   4  þó  ºÿFcüú      b Ù I Z~                                                                                                                                                                                                                                         ÿþÿÿÿýÿþÿýÿþÿúÿýÿÿ              	  
  #            ÿýÿýÿÿÿýÿÿÿþÿüÿýÿþÿûÿýÿùÿùÿöÿêÿéÿèÿõÿøÿòÿùÿüÿüÿüÿüÿýÿþÿþ            " 
     
  ÿýÿþÿòÿøÿíÿëÿéÿõMÿýÿùÿýÿúÿúÿúÿòÿøÿñÿñÿñÿñÿñÿóÿÿÿüÿþÿÿÿýÿþÿÿÿýÿÿÿþÿþÿýÿüÿþÿý                                                    ÿÿÿÿÿþÿûÿÿÿýÿþÿüÿýÿþÿþÿÿÿþÿüÿþÿþÿüÿþÿýÿúÿüÿøÿòÿúÿôÿúÿúÿöÿûÿüÿùÿþÿú                           	           ÿÿÿÿ  ÿþÿÿÿþÿøÿüÿ÷ÿ÷ÿüÿùÿýÿù               
         
        ÿþÿÿÿýÿÿÿÿÿýÿÿÿÿÿþ          ÿÿ h   J                     ÿ_ÿÿÿûÿþÿþÿüÿÿÿýÿþÿý                ÿúÿóÿùÿýÿúÿþÿû               ÿÿ  ÿÿÿÿÿÿÿÿ        
  
 	                ÿþÿþÿþÿúÿýÿýÿøÿýÿüÿù + …                                  ÿþÿùÿúÿñÿýÿøÿüÿùÿ÷ÿìÿêÿõÿêÿöÿüÿùÿüÿýÿùÿýÿýÿúÿýÿûÿüÿûÿûÿþ                                ÿÿ            
    ÿiÿÿÿýÿÿÿþÿþÿýÿüÿþÿý                        
   
  	  
     ÿÿ        ÿÿ  ÿÿÿÿ  ÿþ    ÿÿ      ÿÿÿÿÿüÿýÿûÿþÿûÿþÿýÿúÿýÿýÿúÿýÿýÿûÿýÿûÿûÿþ  ÿÿ                      ÿþÿþÿþÿúÿýÿüÿ÷ÿûÿõÿòÿýÿùÿüÿüÿùÿüÿ÷ÿñÿûÿôÿùÿùÿþÿý                                 ÿÿ         	                    ÿÿÿÿÿÿÿýÿþÿþÿþÿþÿÿÿøÿúÿýÿúÿýÿýÿúÿýÿýÿùÿüÿÿÿüÿýÿþÿû ”ÿ{               ÿÿ  ÿþÿÿÿúÿôÿ¾                               …                                                ÿÿÿÿÿÿÿþÿÿÿüÿÿÿþÿþÿþÿýÿþÿüÿúÿþÿþÿýÿÿÿÿÿÿ               Î7T_<õ  ¤   AfÔ2!    ÿëÿ ·             ÿ   ÿë `                u          ,  » ¡ JÙ *Ñ S‘ Vm Vî ,± J È \É Ä M? M. H± M $˜ X $Ú X• 2‚ ° N³ æ ¶ ¶ w 5 "* 8   & '  
 A £ ? £ÿî B ¢ @6 A A* "+ : #b Mð  
 G õ  	
 
õ  # } d ) ". % 0 #. %) #( * Ø K3 )  #² *@ Du '<ÿë Ï T Ð SF (< . ¦ 8< . Ï TD ( 5? 8 Ð S<ÿë ? å   5 ,ÿðS  6 '6 '. =¤ ” « ]8 )ÿõ$ ,% +† >z 2µ p) F¬ F ÿõ ¹ > ® 2ƒ , á T {' P P €        @¤Éé<MÑö4TLÔê—	ü

‡
 
È
í+S Ê†’ì
„ ö,! \,TZ¯";cˆé	ÙÓõ í$°ù!!š!ò#^$|%Ã&)&V&g&ç'M'i'‚'÷((S(x)x*Z*ý++)+D+ª+»+Ô+å,›-Q-ß/÷00K1Ó1ø212÷3½4z4‹4œ4ä6G6­77P7a7r7Ï8¯9ã=«    u                        –                                 '  	   b 7  	   ™  	   ­  	   »  	   Ï  	   ã  	   ë  	   ÿProtestant - DGLRegularProtestant - DGLProtestant - DGL ©   1 9 9 8   D i g i t a l   G r a p h i c   L a b s   -   A l l   R i g h t s   R e s e r v e d P r o t e s t a n t R e g u l a r P r o t e s t a n t P r o t e s t a n t 1 . 0 2 P r o t e s t a n t ( 2 0 4 )   5 8 9 - 4 3 4 5                                  return function(pixelsX, pixelsY)

  local d = {
    w = pixelsX,
    h = pixelsY,
    layers = {},
  }

  d.clear = function (layer)
    if layer then d.layers[layer] = {} else d.layers = {} end
  end

  d.shift = function (x, y, layer)
    local layers = layer and {d.layers[layer]} or d.layers
    for _, l in pairs(layers) do
      -- TODO move up and left
      for xx=1, x do
        table.insert(l, 0, {})
          l[pixelsX*2] = nil -- keep some pixels outside the visible area to be able to shift them back
      end
      for yy=1, y do
        for _, col in pairs(l) do
          table.insert(col, 0, false)
          col[pixelsY*2] = nil -- keep some pixels outside the visible area to be able to shift them back
        end
      end
    end
  end

  d.bitmap = function (map, pos, layer)
    pos = pos or {0,0}
    for cy, line in ipairs(map) do
      for cx, val in ipairs(line) do
        if val>0 then d.on(cx-1+pos[1], cy-1+pos[2], layer) end
      end
    end
  end

  local getCollisions = function (l1, l2)
    local collisions={}
    for x=0, d.w do
      for y=0, d.h do
        if d.get(x, y, l1) and d.get(x, y, l2) then table.insert(collisions, {x,y}) end
      end
    end
    return collisions
  end

  d.collides = function (l1, l2, callback)
    if #getCollisions(l1, l2) > 0 then callback() end
  end

  d.collisions = function (l1, l2, callback)
    callback(getCollisions(l1, l2))
  end

  d.line = function (from, to, layer)
    if from[1]==to[1] then
      for y=from[2], to[2] do d.on(from[1], y, layer) end
    elseif from[2]==to[2] then
      for x=from[1], to[1] do d.on(x, from[2], layer) end
    end
  end


  local xy = function(x, y)
    if y == nil and type(x) == 'table' then return x[1], x[2] end
    return x, y
  end


  d.set = function(x,y, val, layer)
    x,y=xy(x,y);
    layer = layer or 'default'
    if not d.layers[layer] then d.layers[layer] = {} end
    if not d.layers[layer][x] then d.layers[layer][x] = {} end
    d.layers[layer][x][y] = val
  end

  d.get  = function(x,y, layer)
    x,y = xy(x,y)
    local layers = layer and {d.layers[layer]} or d.layers
    for _, l in pairs(layers) do
      if l[x] and l[x][y] then return true end
    end
  end
  d.isOn = d.get

  d.on = function(x,y, layer) d.set(x, y, true, layer) end
  d.off = function(x,y, layer) d.set(x, y, false, layer) end
  d.toggle = function(x,y, layer) d.set(x,y, not d.get(x,y, layer), layer) end

  return d
end
-- This is the (only) interface the games should interact with

local Display = require('machine.display')
local machine = {
  pause = false,
  gameover = false,
  score = 0,
  speed = 0,
  level = 0,
  input = {
    left=false,
    right=false,
    down=false,
    rotate=false
  },
  display = {
    main = Display(10,20),
    next = Display(4,4),
  },
}

return machine
